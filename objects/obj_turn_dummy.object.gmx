<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>50</depth>
  <persistent>0</persistent>
  <parentName>obj_parent_dummy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ini vars
scene_alpha = obj_control_tutorial.tutorialTextTween[0];
//pass in the top and bottom on create
scene_top = 0//+sprite_gap; //grab this from creation
scene_bottom = GAME_Y+GAME_H;

var i=-1, j = -1, k = 2;
deflectors[++i,(++j)mod k] = object_get_sprite(obj_reflector_parent_basic); //sprite
deflectors[i,(++j)mod k] = 0; //type
deflectors[++i,(++j)mod k] = object_get_sprite(obj_reflector_parent_basic); //sprite
deflectors[i,(++j)mod k] = 0; //type
deflectors[++i,(++j)mod k] = object_get_sprite(obj_reflector_parent_basic); //sprite
deflectors[i,(++j)mod k] = 0; //type
deflectors[++i,(++j)mod k] = object_get_sprite(obj_reflector_parent_basic); //sprite
deflectors[i,(++j)mod k] = 0; //type
//We bias towards showing the basic deflector 
deflectors[++i,(++j)mod k] = object_get_sprite(obj_powerup_parent_ups);
deflectors[i,(++j)mod k] = 1; //type
deflectors[++i,(++j)mod k] = object_get_sprite(obj_powerup_parent_downs);
deflectors[i,(++j)mod k] = 2; //type
deflectors[++i,(++j)mod k] = object_get_sprite(obj_powerup_parent_neutral);
deflectors[i,(++j)mod k] = 3; //type
deflectors[++i,(++j)mod k] = object_get_sprite(obj_powerup_parent_bomb);
deflectors[i,(++j)mod k] = 4; //type

deflector_index = 0;
deflector_col = power_type_colors(deflector_index,0);

deflector_h = 40//32;
deflector_scale = deflector_h/sprite_get_width(object_get_sprite(obj_reflector_parent_basic)); //1.6* cellheight
deflector_tween[0] = 0;
//Calculate the x,y, of the fake deflector
deflector_x = GAME_MID_X;
deflector_y = scene_top -deflector_h/2;

//Duration of star approach
durProjEnter= 1.75*room_speed;
//Duration of star exit
durProjExit = 1.75*room_speed;
//Duration of reloop
durProjCooldown = 1*room_speed;
//Time counter
durTimer = 0;
durTotal = durProjEnter+durProjExit+durProjCooldown;


proj_spr = object_get_sprite(obj_star);
proj_spr_h = deflector_h//8/5 * deflector_h; //1.6* cellheight
proj_scale = proj_spr_h/sprite_get_height(proj_spr)

proj_start_x = deflector_x
proj_start_y = scene_bottom-proj_spr_h/2
//proj_end_y = scene_top - proj_spr_h; //grab this from tutorial
proj_x = proj_start_x;
proj_y = proj_start_y;

proj_speed = (deflector_y - proj_start_y) / durProjEnter //negative (passed in from obj_control_tutorial
proj_dir = 90;
proj_rot = 0;//(proj_dir +270) mod 360;
proj_turn_sign = 1;
proj_state = 2; //0=begin, 1= turn, 2= end

proj_spr_color = COLORS[0];


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///projectile particle create

proj_particle = part_type_create();
part_type_sprite(proj_particle,proj_spr,0,0,0);
part_type_size(proj_particle,1,1,-0.005*RMSPD_DELTA,0*RMSPD_DELTA);
part_type_scale(proj_particle,proj_scale,proj_scale);
part_type_color1(proj_particle,c_white);
//part_type_color2(proj_particle,COLORS[0],COLORS[6]);
part_type_alpha2(proj_particle,1,0.2);
//part_type_speed(proj_particle,1*RMSPD_DELTA,1*RMSPD_DELTA,0*RMSPD_DELTA,0*RMSPD_DELTA);
//part_type_direction(proj_particle,0,359,0*RMSPD_DELTA,0*RMSPD_DELTA);
//part_type_gravity(proj_particle,0*RMSPD_DELTA,270);
part_type_orientation(proj_particle,0,0,0*RMSPD_DELTA,0*RMSPD_DELTA,1);
part_type_life(proj_particle,durProjEnter/1.75,durProjEnter/1.75);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///particle death and garbage collect particle

if part_type_exists(proj_particle)
{
   var gc_array = 0;
   gc_array[0] = proj_particle;
   gc_array[1] = 1*room_speed;
   ds_list_add(global.GC_particles,gc_array);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Calculate scene params

scene_alpha = obj_control_tutorial.tutorialTextTween[0];




if scene_alpha == 1{    
    
    //Initialize random power object for scene
    if durTimer == 0{
        proj_y = proj_start_y;
        proj_x = proj_start_x;
        proj_state = 0;
        
        deflector_index = irandom(array_height_2d(deflectors)-1)
        deflector_col = power_type_colors(deflectors[deflector_index,1],0);
        proj_turn_sign *= -1;//choose(-1,1);
        
        //Deflector Tween-In
        TweenFire(id,deflector_tween,false,EaseLinear,0,1,room_speed*.5)
        part_particles_create_color(PSYS_SUBSTAR_LAYER, deflector_x, deflector_y, p_spawn,deflector_col,1);
        
    }
    
    //Increment scene timer
    durTimer = (durTimer + 1) mod (durTotal);
    
    //Advance scene and spawn particle effects
    if proj_state == 0{ //durTimer &lt;= durProjectile and durTimer &gt; 0{
        proj_y += proj_speed;

        
        if proj_y &lt;= deflector_y{
            proj_state = 1;
            proj_y = deflector_y;
            //Death effect for deflector
            //if not basic or bomb, do special effect
            dType = deflectors[deflector_index,1];
            particleCount = scr_particle_explosion_count(0)
            if dType != 0 and dType != 4{
               particleCount = round(particleCount * 2);
               part_type_orientation(p_destroy_ring_long,0,359,0,0,1); //rangerandom(-2,2);
               part_particles_create_color(PSYS_FIELD_LAYER, deflector_x, deflector_y, p_destroy_sparkles_long, deflector_col, particleCount);//1
               part_particles_create_color(PSYS_FIELD_LAYER, deflector_x, deflector_y, p_destroy_ring_long, deflector_col,1);
            }
            //else regular effect
            else{
               part_particles_create_color(PSYS_FIELD_LAYER, deflector_x, deflector_y, p_destroy_sparkles, deflector_col, particleCount);//1
               part_particles_create_color(PSYS_FIELD_LAYER, deflector_x, deflector_y, p_destroy_ring, deflector_col,1);
            }
    
        }
    }
    //Star Movement after Collision
    if proj_state == 1{
        //Go left is even index, right otherwise
        proj_x += proj_speed * proj_turn_sign

        
        if proj_x*proj_turn_sign &lt;= proj_turn_sign*(deflector_x + proj_speed * durProjExit * proj_turn_sign)
        {
            proj_state = 2;

        }
    }
    if proj_state &lt;= 1{
    
        //Particle trail
        var partCount = 10;//how many particles during scene?
        var partMod = round((durProjEnter)/partCount); 
        if (durTimer mod partMod) == 0 {
            //Create particle
            part_particles_create_colour(PSYS_STAR_LAYER,proj_x,proj_y,
            proj_particle,proj_spr_color,1);
        }
    
    }

}


if !TUTORIAL_ENABLED or obj_control_tutorial.tutorialTitleTween[0] != 1 //or !tutorialActive[0]// 
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy

instance_destroy()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Scene

//Draw Deflector

if proj_state == 0{
    draw_sprite_ext(deflectors[deflector_index,0],0,deflector_x, deflector_y,
    deflector_scale*deflector_tween[0], deflector_scale*deflector_tween[0], 0, deflector_col,scene_alpha);
}


//Draw Star
if proj_state &lt;= 1 {
    draw_sprite_ext(proj_spr,0,proj_x, proj_y,
    proj_scale, proj_scale, proj_rot, proj_spr_color,scene_alpha);

}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
