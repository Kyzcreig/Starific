<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-850</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init vars
startx = x+10
starty = y+10
caught = false
catcher = noone;
caughtAngle = 0
speed = 0
top_speed = 0
current_speed = 0

gridXY = convertXYtoGrid(x,y);
// Vars for Collision Detection
inFieldState = 0; //enabled in alarm event
inFieldActive = 3;

rangeBuffer = 0;

currentStep = 0;
birthStep = STEP
destroyer = 0
//multiplier = 1


oSize = obj_control_game.pFallingSize;
oScale = 1
pFallingPart = noone;

symScale = 0
symColor = 0
symSprite = 0
symDraw = false

objType = 0;
boardClear = false;

//particle alarm
alarm[0] = 2

objIndex = noone;



// Star Modifier Data
scr_reflector_init_star_modifiers();

//tex tx = GAME_X + GAME_W/2;
//tex ty = centerfieldy +pradiusy +cellH*2


//depth is set in alarm event


trailDelay = round(2 / RMSPD_DELTA)

overlapDelay = 2 * trailDelay; 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Powerup effects

if caught and GAME_ACTIVE{

    

   //Mystery object
   if objIndex == obj_powerup_mystery {
        //init vars
        var w =0, wVals, wResult, wRNG;

        // add weights
        if MODE != MODES.MOVES{ //disabled in Moves Mode
            wVals[w] = 2;    wResult[w++] = obj_powerup_growpaddle; //grow
            wVals[w] = 2;    wResult[w++] = obj_powerup_shrinkpaddle; //shrink
        }
        wVals[w] = 2;    wResult[w++] = obj_powerup_faster; //faster
        wVals[w] = 2;    wResult[w++] = obj_powerup_slower; //slower
        //wVals[w] = 1;    wResult[w++] = obj_powerup_1up; //extra lives
        //wVals[w] = 1;    wResult[w++] = obj_powerup_1down; //minus lives
        if MODE != MODES.MOVES{ //disabled in Moves Mode
            wVals[w] = .5;    wResult[w++] = obj_powerup_mirrorpaddle; //mirror
            wVals[w] = .1;    wResult[w++] = obj_powerup_freezepaddle; //freeze
        }
        wVals[w] = .05;    wResult[w++] = obj_powerup_boardclear; //board clear
        if MODE != MODES.MOVES{ //disabled in Moves Mode
            wVals[w] = .05;    wResult[w++] = obj_powerup_boardfill; //boardfill
        }
        wVals[w] = 2;    wResult[w++] = obj_powerup_points; //more points
        wVals[w] = 2;    wResult[w++] = obj_powerup_antipoints; //less points
        wVals[w] = .5;    wResult[w++] = obj_powerup_bigstar; //huge star
        wVals[w] = .1;    wResult[w++] = obj_powerup_halfangleturn; //45 deg turns
        wVals[w] = .1;    wResult[w++] = obj_powerup_threehalvesangle; //135 deg turns
        wVals[w] = .1;    wResult[w++] = obj_powerup_randomturn; //
        wVals[w] = .1;    wResult[w++] = obj_powerup_pierce; //
        wVals[w] = .1;    wResult[w++] = obj_powerup_reverseturn; //
        wVals[w] = .1;    wResult[w++] = obj_powerup_diagturn; //
        wVals[w] = 1;    wResult[w++] = obj_powerup_2balls; //double star
        wVals[w] = .5;    wResult[w++] = obj_powerup_3balls; //triple star
        wVals[w] = .25;    wResult[w++] = obj_powerup_4balls; //quad star
        if MODE != MODES.MOVES{ //disabled in Moves Mode : Tappers
            wVals[w] = .1;    wResult[w++] = obj_powerup_slowpaddle; //slow paddle
            wVals[w] = .1;    wResult[w++] = obj_powerup_multistar; //multi star
            wVals[w] = .1;    wResult[w++] = obj_powerup_addgrow; //multi grow
            wVals[w] = .1;    wResult[w++] = obj_powerup_subshrink; //multi shrink
            wVals[w] = .1;    wResult[w++] = obj_powerup_addslower; //multi slow
            wVals[w] = .1;    wResult[w++] = obj_powerup_subfaster; //multi fast
            wVals[w] = .1;    wResult[w++] = obj_powerup_shorterpowerdowns; //
            wVals[w] = .1;    wResult[w++] = obj_powerup_longerpowerups; //
            wVals[w] = .1;    wResult[w++] = obj_powerup_density_doubler; //
        }
        wVals[w] = .025;    wResult[w++] = obj_powerup_powersallclear; //power all clear
        wVals[w] = .025;    wResult[w++] = obj_powerup_powerupsclear; //power up clear
        wVals[w] = .025;    wResult[w++] = obj_powerup_powerdownsclear; //power down clear
        if MODE == MODES.MOVES{
           wVals[w] = .1;    wResult[w++] = obj_powerup_staregg; //extra staregg
        }
        if MODE != MODES.MOVES{ //disabled in Moves Mode : Tappers/Paddle stuff
           //wVals[w] = .1;    wResult[w++] = obj_powerup_invertpaddle; //paddle inversion
           wVals[w] = .1;    wResult[w++] = obj_powerup_multibonus; //extra combo multiplier
           wVals[w] = .1;    wResult[w++] = obj_powerup_multimalus; //disabled combos
           wVals[w] = .1;    wResult[w++] = obj_powerup_splitpaddle; //split paddle
           wVals[w] = .1;    wResult[w++] = obj_powerup_offsetpaddle; //split paddle
        }
        if enableVC {
            wVals[w] = 1;    wResult[w++] = obj_powerup_cash_1; //starcash
            wVals[w] = .1;    wResult[w++] = obj_powerup_cash_1; //starcash
            wVals[w] = .1;    wResult[w++] = obj_powerup_cash_2; //starcash
            wVals[w] = .1;    wResult[w++] = obj_powerup_cash_5; //starcash
            wVals[w] = .1;    wResult[w++] = obj_powerup_cash_10; //starcash
            //wVals[w] = .1;    wResult[w++] = obj_powerup_cash_rng; //starcash
            if MODE != MODES.MOVES{ 
                wVals[w] = .1;    wResult[w++] = obj_powerup_cash_tap; //starcash
            }
            wVals[w] = .1;    wResult[w++] = obj_powerup_cash_x2; //starcash
            
        }
        
        
        //draw from hat
        wRNG = random(1.0)
        //scale probability
        wRNG *= array_sum_1d(wVals) 
        for( var w = 0; wRNG &gt; wVals[w]; w++) wRNG -= wVals[w];
        
        //Set Result
        objIndex = wResult[w];
        
        //if we want the text colors to be right
        //we can manually set it our set it as an adjacent array above
        //we'll need to manually set them to the appropriate type
        //with the powerup color type script probably
        //not a big deal we can decide if it's a problem later
        
        //power_type_colors(1,0)
        
        //it may be worth oursourcing this process to the deflector initialization
        //and then settings some mystery var which we grab here.
   }
   
   
   // Select Powerup Effect
   switch objIndex {
   
   case obj_powerup_growpaddle:
   
        POWER_grow[@ 0] += 1; 
   break;
   
   case obj_powerup_shrinkpaddle:
        POWER_shrink[@ 0] += 1;  
   break;
   
   
   case obj_powerup_faster:
        POWER_faster[@ 0] += 1;
   break;
   
   
   case obj_powerup_slower:
        POWER_slower[@ 0] += 1;
   break;
   
   
   case obj_powerup_1up:
        if MODE == MODES.ARCADE{
           lives += 1
           text = '+1 life!'
        }
        if MODE == MODES.MOVES{
           MOVES_REMAINING += 1
           text = '+1 move!'
        }
        if MODE == MODES.TIME{
           time_left *= 1.5
           text = '+50% time'
        }
        if MODE == MODES.SANDBOX{
           text = '+20 combo' //not implemented
        }
        //Jiggles lives gui
        obj_control_game.gui_jiggle[1,0] = obj_control_game.gui_jiggletime
   break;
   
   
   case obj_powerup_1down:
        if MODE == MODES.ARCADE{
           lives -= 1
           text = '-1 life!'
        }
        if MODE == MODES.MOVES{
           MOVES_REMAINING -= 1
           text = '-1 move!'
        }
        if MODE == MODES.TIME{
           time_left /= 3
           text = '-33% time'
        }
        if MODE == MODES.SANDBOX{
           text = '-20 combo' //not implemented
        }
        //Jiggles lives gui
        obj_control_game.gui_jiggle[1,0] = obj_control_game.gui_jiggletime
   break;
   
   
   case obj_powerup_mirrorpaddle:
        POWER_mirror[@ 0] += 1;
        with(instance_create(-1000,-1000,obj_launcher_mirror)){
              switch (POWER_mirror[@ 0]-1) mod 7{
                 case 0:
                      inversion = 180
                      marker_color = c_green
                      break
                 case 1:
                      inversion = 90
                      marker_color = c_orange
                      break
                 case 2:
                      inversion = 270
                      marker_color = c_purple
                      break
                 case 3:
                      inversion = 45
                      marker_color = c_teal
                      break
                 case 4:
                      inversion = 135
                      marker_color = c_aqua
                      break
                 case 5:
                      inversion = 225
                      marker_color = c_maroon
                      break
                 case 6:
                      inversion = 315
                      marker_color = c_black
                      break
            }
        }
   break;
   
   
   case obj_powerup_freezepaddle:
        POWER_freeze[@ 0] += 1;  
   break;
   
   
   case obj_powerup_boardclear:
        txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
        draw_set_font(txt_font)
        txt_text = 'starnova!';
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
             txt_text,image_blend,txt_font)// fnt_game_bn_40_bold

        scr_boardclear(); 
        scr_sound(sd_catch_power_boardclear, 1, false);
            //Something to consider: when you get board clear which triggers board fill
            //in moves mode this is potentially most aggregious, but i think it's ok either way
   break;
   
   
   case obj_powerup_boardfill:
        txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
        draw_set_font(txt_font)
        txt_text = 'super starnova!';
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
             txt_text,image_blend,txt_font)// fnt_game_bn_40_bold
             
             
             
        scr_boardfill()
        scr_sound(sd_catch_power_boardclear, 1, false);
   break;
   
   
   case obj_powerup_points:
        POWER_pmulti[@ 0] += 1;
   break;
   
   
   case obj_powerup_antipoints:
        POWER_pdivis[@ 0] += 1;
   break;
   
   
   case obj_powerup_bigstar:
        POWER_hugestar[@ 0] +=1
   break;
   
   
   case obj_powerup_halfangleturn:
        POWER_halfangle[@ 0] +=1
        
   break;
   case obj_powerup_threehalvesangle:
        POWER_threehalfangle[@ 0] +=1
        
   break;
   case obj_powerup_randomturn:
        POWER_randomangle[@ 0] +=1
        
   break;
   case obj_powerup_reverseturn:
        POWER_reverseangle[@ 0] +=1
        
   break;
   case obj_powerup_pierce:
        POWER_noangle[@ 0] +=1
        
   break;
   case obj_powerup_diagturn:
        POWER_diagturn[@ 0] +=1
   break;
   case obj_powerup_2balls:
        var obj = shooter_nearest_valid(x,y);
        if obj != noone{
            scr_popup_text_field_moving(obj.x,obj.y,'double star!',image_blend)
            with (obj){
                 var copyFieldXY = convertGridtoXY(intGridXY[0], intGridXY[1]);
                 spawn_star(direction +180,copyFieldXY[0],copyFieldXY[1])
            }
        }
   break;
   
   case obj_powerup_3balls:
        var obj = shooter_nearest_valid(x,y);
        if obj != noone{
            scr_popup_text_field_moving(obj.x,obj.y,'triple star!',image_blend)
            with (obj){
                 var copyFieldXY = convertGridtoXY(intGridXY[0], intGridXY[1]);
                 spawn_star(direction +90,copyFieldXY[0],copyFieldXY[1])
                 spawn_star(direction -90,copyFieldXY[0],copyFieldXY[1])
            }
        }
   break;
   
   case obj_powerup_4balls:
        var obj = shooter_nearest_valid(x,y);
        if obj != noone{
            scr_popup_text_field_moving(obj.x,obj.y,'quadruple star!',image_blend)
            with (obj){
                 var copyFieldXY = convertGridtoXY(intGridXY[0], intGridXY[1]);
                 spawn_star(direction +180,copyFieldXY[0],copyFieldXY[1])
                 spawn_star(direction +90,copyFieldXY[0],copyFieldXY[1])
                 spawn_star(direction -90,copyFieldXY[0],copyFieldXY[1])
            }
        }
   break;
   
   case obj_powerup_slowpaddle:
        POWER_slowpaddle[@ 0] +=1
        
   break;
   case obj_powerup_multistar:
        POWER_multistar[@ 0] +=1
        
   break;
   case obj_powerup_addgrow:
        POWER_addgrow[@ 0] +=1
        
   break;
   case obj_powerup_subshrink:
        POWER_subshrink[@ 0] +=1
        
   break;
   case obj_powerup_addslower:
        POWER_addslower[@ 0] +=1
        
   break;
   case obj_powerup_subfaster:
        POWER_subfaster[@ 0] +=1
        
   break;
   case obj_powerup_longerpowerups:
        POWER_longerpowerups[@ 0] +=1
        
   break;
   case obj_powerup_shorterpowerdowns:
        POWER_shorterpowerdowns[@ 0] +=1
        
   break;
   case obj_powerup_powersallclear:
        txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
        draw_set_font(txt_font)
        txt_text = "all powers clear!";
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
        txt_text,image_blend,txt_font)
        scr_clear_powers();
        
   break;
   case obj_powerup_powerupsclear:
        txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
        draw_set_font(txt_font)
        txt_text = 'powerup clear!';
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
        txt_text,image_blend,txt_font)
        scr_clear_power_ups();
        
   break;
   case obj_powerup_powerdownsclear:
        txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
        draw_set_font(txt_font)
        txt_text = 'powerdown clear!';
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
        txt_text,image_blend,txt_font)
        scr_clear_power_downs();
        
   break;
   case obj_powerup_staregg:
        txt_font = fnt_game_bn_40_bold//fnt_game_bn_40_bold;//; 
        draw_set_font(txt_font)
        txt_text = "+1 "+string_replace(boardMixers[0,3],"#"," ");
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy+txt_height,
        txt_text,image_blend,txt_font)
        
        with (obj_control_game){
             boardMixers[bMStarIndex,0] += 1;
        }
   break;
   
   case obj_powerup_invertpaddle:
        POWER_invertcontrols[@ 0] +=1
   break;
   
   case obj_powerup_multibonus:
        POWER_multibonus[@ 0] +=1
        
   break;
   case obj_powerup_multimalus:
        POWER_multimalus[@ 0] +=1
        
   break;
   case obj_powerup_splitpaddle:
        POWER_splitpaddle[@ 0] +=1
   break;
   case obj_powerup_cash_1:
        scr_starcash_power_caught(1);
   break;
   case obj_powerup_cash_2:
        scr_starcash_power_caught(2);
   break;
   case obj_powerup_cash_5:
        scr_starcash_power_caught(5);
        
   break;
   case obj_powerup_cash_10:
        scr_starcash_power_caught(10);
        
   break;
   case obj_powerup_cash_rng:
        scr_starcash_power_caught(irandom_range(1,15));
   break;
   case obj_powerup_cash_tap:
        POWER_cashtap[@ 0] +=1;
   break;
   case obj_powerup_offsetpaddle:
        txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
        draw_set_font(txt_font)
        txt_text = "paddle offset!";
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
             txt_text,image_blend,txt_font)// fnt_game_bn_40_bold
             
        POWER_offsetpaddle[@ 0] +=1;
   break;
   case obj_powerup_cash_x2:
        txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
        draw_set_font(txt_font)
        txt_text = "cash doubler!";
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
             txt_text,image_blend,txt_font)// fnt_game_bn_40_bold
             
        POWER_cashx2[@ 0] +=1;
   break;
   case obj_powerup_density_doubler:
        txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
        draw_set_font(txt_font)
        txt_text = "density doubler!";
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
             txt_text,image_blend,txt_font)// fnt_game_bn_40_bold
             
        POWER_density_doubler[@ 0] +=1;
   break;
   
   }
   /*
   
   //NB: So doing a text for a lot of these powerups isn't a bad idea 
   now that we've create out 3 row system.  But I think it'll be ok.
   
   If we did do that it'd be a good idea to make a script that takes text
   color and row and wraps the scr_popup text.
   
   var data = scr_deflector_get_data(objIndex)
   var name = data[5];

    txt_font = fnt_game_bn_40_bold;//fnt_game_bn_30_black; 
    draw_set_font(txt_font)
    txt_text = string_replace(name,"#"," ")+"!";
    txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
    scr_popup_text_field_static(centerfieldx,centerfieldy-txt_height,
         txt_text,image_blend,txt_font)// fnt_game_bn_40_bold
   
   */
   
   
   //Play catch sound for this powerup
   scr_catch_power_sound(objIndex,objType);
   
   //Update Caught Count For This Power
   scr_deflector_add_stat(objData, 8);
   
   
   
   //FOR POWERUP CATCH COMBOS
   if true//boardClearedTimer &lt;= 0 and boardFilledTimer &lt;= 0
    //NB: Evaluate me!
    // I think it doesn't hurt to have the cooldown but let's try without it.
    //Since we have diminishing returns on other stuff now.
     //(MODE != MODES.MOVES or boardFilledTimer &lt;= 0)
                    //NB: We removed boardfill/clear from Moves because OP
   {
        scr_increment_combo(objType)
        //NB: Maybe boardclear should make additional combos count half
   }
   var added = 5;
   score+= added
   added = scr_calculate_points(added);
   score_p1 += added
   lastPPD += added
   lastDCatches += 1
   
   if MODE == MODES.TIME{
       time_left += added
    }
}

//Particle effect happens on destruction
//Good power effect
if objType == 1{
    part_particles_create_color(PSYS_SUBSTAR_LAYER, x, y, p_catch_good,image_blend, 200);//

    //disable jiggle paddle when catches good powerup
    if caught and paddle_id != noone and instance_exists(paddle_id){
       with(paddle_id){
           cd_jiggle[0,0] = 0;
           padColorTimers[other.objType-1] = max(padColorTimers[other.objType-1],room_speed*.5)
       }
    }
    
    /*if catcher != noone and instance_exists(catcher){
       with(catcher){
           cd_jiggle[0,0] = 0;
       }
    }*/
}
//Bad power effect
else if objType == 2{
    part_particles_create_color(PSYS_SUBSTAR_LAYER, x, y, p_catch_bad,image_blend, 100);//number
    
    //disable jiggle paddle when catches neutral powerup
    if caught and paddle_id != noone and instance_exists(paddle_id){
       with(paddle_id){
           cd_jiggle[0,0] = jiggletime;
           padColorTimers[other.objType-1] = max(padColorTimers[other.objType-1],room_speed*.5)
       }
    }
    //jiggle paddle when catches bad powerup
    /*if catcher != noone and instance_exists(catcher){
       with(catcher){
           cd_jiggle[0,0] = jiggletime;
       }
    }*/
}
//Neutral power effect
else {// if objType == 3{
    part_particles_create_color(PSYS_SUBSTAR_LAYER, x, y, p_catch_neutral,image_blend, 150);//150

    //disable jiggle paddle when catches neutral powerup
    if caught and paddle_id != noone and instance_exists(paddle_id){
       with(paddle_id){
           cd_jiggle[0,0] = 0;
           padColorTimers[other.objType-1] = max(padColorTimers[other.objType-1],room_speed*.5)
       }
    }
    /*if catcher != noone and instance_exists(catcher){
       with(catcher){
           cd_jiggle[0,0] = 0;
       }
    }*/
}
//part_type_gravity(p_catch,0.2*RMSPD_DELTA,direction);
//part_particles_create_color(PSYS_SUBSTAR_LAYER, x, y, p_catch,image_blend, 200);//number

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///garbage collect particle [disabled]

/*
if part_type_exists(pFallingPart)
{
   var gc_array = 0;
   gc_array[0] = pFallingPart;
   gc_array[1] = 1*room_speed;
   ds_list_add(global.GC_particles,gc_array);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set sprites and particles

//Set Speed
current_speed = top_speed;
speed = current_speed * DELTA_TIME_SCALAR;


// Set Direction
image_angle = (direction +270) mod 360

// Flag As Catchable
inFieldState = inFieldActive;

// Draw Symbol
symDraw = true;//maybe disable this

// Set Particle Effect
var pSpr, pDir;
//Up Powers
if objType == 1{pSpr = 0;/*sprite_index =s_v_deflector_powerdown;*/}
//Down Powers
else if objType == 2{pSpr = 1;}//= 0; sprite_index = object_get_sprite(obj_powerup_parent_ups);}
//Be sure to upate tutorial object if you change this
//Neutral Powers
else if  objType == 3{pSpr = 2;}

//Set Direction of particle effect
pDir = image_angle div 45;

pFallingPart = pFallingParticle[pSpr,pDir]

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Falling Powerup Effects

/*  NB: End step is used so that the particles spawn at the right X/Y location.


*/

// Set Delta Speed
//speed = raw_speed * DELTA_TIME_SCALAR
    /*
        For this to work we'd need to refactor scr_avoid_overlap_dynamic to
         use a raw_speed instance variable instead of speed.
    */
// Set Speed
speed = current_speed * DELTA_TIME_SCALAR;

currentStep = STEP - birthStep// +1; 
//auto trigger in MOVES_LEFT mode
if MODE == MODES.MOVES{
    if currentStep == 2{
       caught = true
       instance_destroy()
    }
}


// Draw Falling Power Particle Trail
if (currentStep mod trailDelay) == 0 {
    if part_type_exists(pFallingPart){
        part_particles_create_colour(PSYS_FIELD_LAYER,x,y,pFallingPart,image_blend,1);
    }
}



//Anti overlapping, one slows for other to pass
if currentStep mod (overlapDelay) == 0 
{

    //NB: recall the falling powerup is scaled 1.25X of cellSize for legibility
    //var __collided = collision_rectangle(x-(cellW)/2,y-(cellH)/2,x+(cellW)/2,y+(cellH)/2,obj_powerup_falling,false,true)
    var __collided = collision_circle(x,y,oSize,obj_powerup_falling,false,true)
    scr_avoid_overlap_dynamic(__collided)
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keep at bottom (Out of Bounds Code)

// Self Destruct if Hitting Outside
scr_out_of_bounds_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy

instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Falling Powerup Symbol



// Set Color
image_blend = COLORS[objType];

// Draw Self
draw_self()

if symDraw{//alarm[0] &lt; 1 and 
   var symColor =  power_type_colors(objType,1);
   draw_sprite_ext(symSprite,0,x,y,symScale,symScale,0,symColor,1)
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>10,10</point>
  </PhysicsShapePoints>
</object>
