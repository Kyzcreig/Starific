<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>50</depth>
  <persistent>0</persistent>
  <parentName>obj_parent_dummy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ini vars
scene_alpha = obj_control_tutorial.tutorialTextTween[0];
//pass in the top and bottom on create
scene_top = 0//+sprite_gap; //grab this from creation
scene_bottom = GAME_Y+GAME_H;

//Calculate the x,y, of the fake paddle
paddle_x = GAME_MID_X;
//i'll need about 120 for the cooldown icon so it has breathing space
paddle_y = scene_bottom -60;//- 160;
paddle_w = 256;
paddle_h = PADDLE_H;

//Duration of star flying
durProjectile = 2.5*room_speed;
//Duration until reloop
durCooldown = 4*room_speed;
//Time counter
durTimer = 0;
durTotal = durProjectile+durCooldown;

paddle_jiggler = 0;

proj_spr = object_get_sprite(obj_star);
proj_spr_h = 8/5*cellH; //1.6* cellheight
proj_scale = proj_spr_h/sprite_get_height(proj_spr)

proj_start_x = paddle_x
proj_start_y = paddle_y+paddle_h/2//scene_top + cellH * obj_control_game.pFallingScalar/2;
proj_end_y = scene_top - proj_spr_h; //grab this from tutorial
proj_x = proj_start_x;
proj_y = proj_start_y;

proj_speed = (scene_top - proj_end_y) / durProjectile //negative (passed in from obj_control_tutorial
proj_dir = 90;
proj_rot = 0;//(proj_dir +270) mod 360;

proj_state = 1; //0=only projectile, 1= both, 2= only cooldown icon

proj_spr_color = COLORS[0];


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///projectile particle create

proj_particle = part_type_create();
part_type_sprite(proj_particle,proj_spr,0,0,0);
part_type_size(proj_particle,1,1,-0.005*RMSPD_DELTA,0*RMSPD_DELTA);
part_type_scale(proj_particle,proj_scale,proj_scale);
part_type_color1(proj_particle,c_white);
//part_type_color2(proj_particle,COLORS[0],COLORS[6]);
part_type_alpha2(proj_particle,1,0.2);
//part_type_speed(proj_particle,1*RMSPD_DELTA,1*RMSPD_DELTA,0*RMSPD_DELTA,0*RMSPD_DELTA);
//part_type_direction(proj_particle,0,359,0*RMSPD_DELTA,0*RMSPD_DELTA);
//part_type_gravity(proj_particle,0*RMSPD_DELTA,270);
part_type_orientation(proj_particle,0,0,0*RMSPD_DELTA,0*RMSPD_DELTA,1);
part_type_life(proj_particle,durProjectile/2,durProjectile/2);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///particle death and garbage collect particle

if part_type_exists(proj_particle)
{
   var gc_array = 0;
   gc_array[0] = proj_particle;
   gc_array[1] = 1*room_speed;
   ds_list_add(global.GC_particles,gc_array);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Calculate scene params

scene_alpha = obj_control_tutorial.tutorialTextTween[0];




if scene_alpha == 1{    
    
    //Initialize random power object for scene
    if durTimer == 0{
        proj_y = proj_start_y;
        proj_state = 0;
        
        //IS THIS FACING THE RIGHT DIRECTION OR SHOULD IT BE 180 DEGREES THE OTHER WAY
        //it looks kind of bad imo
        //Create Particle Effect Launch
        /*
        part_type_direction(p_launch,0,359,0*RMSPD_DELTA,0*RMSPD_DELTA);
        part_type_gravity(p_launch,.075*RMSPD_DELTA,90);//.09
        //part_type_gravity(p_launch,.0*RMSPD_DELTA,90);//.09
        part_particles_create_color(PSYS_SUBSTAR_LAYER, proj_start_x, proj_start_y,p_launch,proj_spr_color, 50);//100);//
        */
        
        //scr_sound(sd_turn_begin,1,false)
        
    }
    
    //Increment scene timer
    durTimer = (durTimer + 1) mod (durTotal);
    
    //Advance scene and spawn particle effects
    if proj_state == 0{ //durTimer &lt;= durProjectile and durTimer &gt; 0{
        proj_y = proj_start_y + proj_speed*durTimer;
        //Particle trail
        var partCount = 20;//how many particles during scene?
        var partMod = round(durProjectile/partCount); 
        if (durTimer mod partMod) == 0 {
            //Create particle
            part_particles_create_colour(PSYS_FIELD_LAYER,proj_x,proj_y,
            proj_particle,proj_spr_color,1);
        }

        
        if proj_y &lt;= proj_end_y  and proj_state == 0{
            proj_state = 1;
            //Create Particle Effect Death
            if false
                part_particles_create_colour(PSYS_SUBSTAR_LAYER, x, y, p_catch,proj_spr_color,200);

        }
    }

}


if !TUTORIAL_ENABLED or obj_control_tutorial.tutorialTitleTween[0] != 1 //or !tutorialActive[0]// 
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy

instance_destroy()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Scene


//Draw Paddle
var sp_xscale = paddle_w / 128;
var sp_yscale = PADDLE_H / 128;
var paddle_jig_x = 0;
var paddle_jig_y = 0;
if paddle_jiggler &gt; 0{
    paddle_jiggler -= 1;
    var jiggle_strength = 6;
    paddle_jig_x = random(1)*jiggle_strength;
    paddle_jig_y = random(1)*jiggle_strength;
}

draw_sprite_ext(s_v_background_solid,0,paddle_x-paddle_w/2+paddle_jig_x, paddle_y+paddle_jig_y,
sp_xscale, sp_yscale, 0, COLORS[0],scene_alpha);


//Draw Projectile
if (proj_state mod 3) == 0 {
    //draw deflector
    draw_sprite_ext(proj_spr,0,proj_x, proj_y,
    proj_scale, proj_scale, proj_rot, proj_spr_color,scene_alpha);
    
    //so one way to go about this is to draw a small square of background color
    //where the shooter is supposed to disappear
    //then it will natural appear to fade out
    //but we can try this normally first and see how it goes
}
/*
if proj_state &gt;= 1{



}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
