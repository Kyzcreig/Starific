<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ini vars, powerup durations
scr_powers_controler_init();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///timedown and track counts (sounds too)
var obj;

/*if instance_exists(obj_launcher) and 
paddle_id.pad_xscale[0]*PADDLE_W*(POWER_mirror[@ 0]+1) / RAIL_LENGTH &gt; .90{ *paddle_id.image_xscale
//image_xscale would also count the stretching effect on fast rotation
    railOverload = true;
}
else railOverload = false;*/
//Detect Overloaded Rail Coverage
if instance_exists(obj_launcher) {
   railCoverage = paddle_id.pad_xscale[0]*PADDLE_W*(POWER_mirror[@ 0]+1) / RAIL_LENGTH / (POWER_addgrow[@ 7]*POWER_subshrink[@ 7]);
}

if railCoverage &gt; .80 { 
   railOverload = true;
   // Paddle Coverage Achievement
   if railCoverage &gt;= 1 and MOVE_ACTIVE {
        // Set Achievement
        scr_unlock_set_status(5,0,2,false); //NB: Avoid I/O in steps
   }
}
else {
   railOverload = false;
}
    

//Set Duration Modifying Flag
if modifyDur != 0{
   //Sets Flag for detection
   if abs(modifyDur) &lt; 1{
      modifyDur = round(modifyDur*10);
   }
   //Clears Flag
   else{
      modifyDur = 0;
   }
   //We Do this this way so that we can set all durations on the same STEP
}


//Scale paddle
if paddleScale {
    if GAME_ACTIVE scr_scale_paddle(); 
    paddleScale=false;
}


// Decrement Board Wide Effects Spawner CD
if boardWideEffectTimer &gt; 0 {
    boardWideEffectTimer--;
}
// Decrement Board Fill CD
if boardFilledTimer &gt; 0 {
    boardFilledTimer--;
}
// Decrement Board Clear CD
if boardClearedTimer &gt; 0 {
    boardClearedTimer--;
}

// Clear Touch Tap Flag
touchPadTap = false;

/*
// Create Temp Power Vars
var //NB: Not really necessary..
powerArray,
powerTimer,
powerMaxDur, 
powerIndex,
antiPowerArray,
antiPowerTimer,
antiPowerIndex;
*/

//POWER_grow[@ 0] stuff
powerArray = POWER_grow;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_shrink;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8]

if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        powerArray[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
    paddleScale = true;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        paddleScale = true;
    }
    else powerTimer[| i] -= max(1,scr_power_get_quick_deplete_value());
    //else powerTimer[| i] -= (1+ railOverload*ds_list_size(powerTimer))
}





//POWER_shrink[@ 0] stuff
powerArray = POWER_shrink;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_grow;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        powerArray[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
    paddleScale = true;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        paddleScale = true;
    }
    else powerTimer[| i] -= 1//(1+ railOverload*ds_list_size(powerTimer))
        //Maybe we don't hyper decrement the shrinks so you might end up super small after a big paddle.
    //else powerTimer[| i] = powerTimer[| i] - (1)
    
    /*if railCoverage &gt; .3 and i == ds_list_size(powerTimer) - 1{
       powerTimer[| i] = powerTimer[| i] - sqr(i)*railOverload
    }*/
    
    
}





//POWER_faster[@ 0] stuff
powerArray = POWER_faster;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_slower;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        POWER_faster[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }


    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}



//POWER_slower[@ 0] stuff
powerArray = POWER_slower;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
antiPowerArray = POWER_faster;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        POWER_slower[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
       
}






//POWER_pmulti[@ 0] stuff
powerArray = POWER_pmulti;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_pdivis;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        POWER_slower[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
    
}



//POWER_pdivis[@ 0] stuff
powerArray = POWER_pdivis;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_pmulti;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        POWER_slower[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
}




//POWER_mirror[@ 0] stuff
powerArray = POWER_mirror;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    //Multifaceted Achievement
    if powerArray[@ 0] &gt;= 3 {
        // Set Achievement
        scr_unlock_set_status(5,1,2,false); //NB: Avoid I/O in steps
    }
    
    
}
// Update Array of Mirrors each step
arr_of_mirrors = noone;
var count = instance_number(obj_launcher_mirror)
for (z = 0 ; z &lt; count; z++){ 
    arr_of_mirrors[z] = instance_find(obj_launcher_mirror,z)
    // Reset Low Time Coloring/Alpha
    with (arr_of_mirrors[z]) {  
        pad_alpha = 1; 
        mirrorColorDeath = false; 
    }
}

//if POWER_mirror[@ 7] != -1 POWER_mirror[@ 7] = -1;
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    // If Timer Finished
    if powerTimer[| i] &lt;= 0{
        // Delete Timer
        ds_list_delete(powerTimer,i)
        
        // Decrement Power Counter
        powerArray[@ 0] -= 1;   
        
    
        var newestMirror = scr_paddle_mirror_get_nth(arr_of_mirrors, powerArray[@ 0]);
        // Check that mirror isn't already destroyed by a game restart
        if instance_exists(newestMirror) {
            //  With Mirror Paddle
            with (newestMirror) {
                // Flag it Tweening
                tweeningOut = true; //NB: Prevent Double Count in the iteration loop
                // Tween it Out
                scr_paddle_tween_out()
                
                //Set Pad Alpha to 1
                pad_alpha = 1;
                //Set Color back to normal if gameover
                if !GAME_ACTIVE {
                    mirrorColorDeath = false;
                }
            }
        }
    }
    else {
        // Dock Time From Timer
        powerTimer[| i] -= max(1,(POWER_grow[@ 0] &lt; 2)*(1 + scr_power_get_quick_deplete_value()));
                        /*  NB: We don't start hyperdecrementing mirrors until all grows are gone.  
                            this will fascillitate more, (smaller) higher duration mirros, which makes things more fun.
                        */
        
        // If Time Remaining &lt; 10% of max time
        if powerTimer[| i] &lt; powerMaxDur * .20 {
            // Here we find the corresponding Mirror (not tweening) and blink its alpha
            var currentMirror = scr_paddle_mirror_get_nth(arr_of_mirrors, i);
            if instance_exists(currentMirror) {
                with (currentMirror) {
                    // Lerp the Pad Alpha
                    pad_alpha = lerp(.20, .80, FULL_SECOND_LERP);
                    // Flag Mirror Color as Dying (So Color can be LERPed
                    //mirrorColorDeath = true;
                }
            }
            
        }
        
    }
    
}



//POWER_freeze[@ 0] stuff
powerArray = POWER_freeze;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    // Freeze Paddle Motion
    PADDLE_MOTION = 0;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    
    //Tapper stuff
    if mouse_check_button_pressed(mb_left){
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/10;
       touchPadTap = true; 
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        // Un Freeze Paddle Motion
        if powerArray[@ 0] == 0 {
            PADDLE_MOTION = 1;
        }

    }
    else powerTimer[| i] -= 1
    
}


//POWER_hugestar[@ 0] stuff
powerArray = POWER_hugestar;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else{
        // Dock Time
        powerTimer[| i] -= max(1, .75*global.ActiveStarCount*(1 + .33 * railOverload));
                        /*NB: We Dock time based on star count to avoid crazy positive feedback.
                                We also decrement it faster if the rail is overloaded.
                        */
    
    }
}


//POWER_halfangle[@ 0] stuff
powerArray = POWER_halfangle;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    //ds_list_clear(POWER_halfangle[@ 1]); POWER_halfangle[@ 0]=0;
    ds_list_clear(POWER_threehalfangle[@ 1]); POWER_threehalfangle[@ 0]=0;
    ds_list_clear(POWER_randomangle[@ 1]); POWER_randomangle[@ 0]=0;
    ds_list_clear(POWER_reverseangle[@ 1]); POWER_reverseangle[@ 0]=0;
    ds_list_clear(POWER_noangle[@ 1]); POWER_noangle[@ 0]=0;
    ds_list_clear(POWER_diagturn[@ 1]); POWER_diagturn[@ 0]=0;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}



//POWER_threehalfangle[@ 0] stuff
powerArray = POWER_threehalfangle;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    ds_list_clear(POWER_halfangle[@ 1]); POWER_halfangle[@ 0]=0;
    //ds_list_clear(POWER_threehalfangle[@ 1]); POWER_threehalfangle[@ 0]=0;
    ds_list_clear(POWER_randomangle[@ 1]); POWER_randomangle[@ 0]=0;
    ds_list_clear(POWER_reverseangle[@ 1]); POWER_reverseangle[@ 0]=0;
    ds_list_clear(POWER_noangle[@ 1]); POWER_noangle[@ 0]=0;
    ds_list_clear(POWER_diagturn[@ 1]); POWER_diagturn[@ 0]=0;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}

//POWER_randomangle[@ 0] stuff
powerArray = POWER_randomangle;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    ds_list_clear(POWER_halfangle[@ 1]); POWER_halfangle[@ 0]=0;
    ds_list_clear(POWER_threehalfangle[@ 1]); POWER_threehalfangle[@ 0]=0;
    //ds_list_clear(POWER_randomangle[@ 1]); POWER_randomangle[@ 0]=0;
    ds_list_clear(POWER_reverseangle[@ 1]); POWER_reverseangle[@ 0]=0;
    ds_list_clear(POWER_noangle[@ 1]); POWER_noangle[@ 0]=0;
    ds_list_clear(POWER_diagturn[@ 1]); POWER_diagturn[@ 0]=0;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}



//POWER_reverseangle[@ 0] stuff
powerArray = POWER_reverseangle;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    ds_list_clear(POWER_halfangle[@ 1]); POWER_halfangle[@ 0]=0;
    ds_list_clear(POWER_threehalfangle[@ 1]); POWER_threehalfangle[@ 0]=0;
    ds_list_clear(POWER_randomangle[@ 1]); POWER_randomangle[@ 0]=0;
    //ds_list_clear(POWER_reverseangle[@ 1]); POWER_reverseangle[@ 0]=0;
    ds_list_clear(POWER_noangle[@ 1]); POWER_noangle[@ 0]=0;
    ds_list_clear(POWER_diagturn[@ 1]); POWER_diagturn[@ 0]=0;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}



//POWER_noangle[@ 0] stuff
powerArray = POWER_noangle;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    ds_list_clear(POWER_halfangle[@ 1]); POWER_halfangle[@ 0]=0;
    ds_list_clear(POWER_threehalfangle[@ 1]); POWER_threehalfangle[@ 0]=0;
    ds_list_clear(POWER_randomangle[@ 1]); POWER_randomangle[@ 0]=0;
    ds_list_clear(POWER_reverseangle[@ 1]); POWER_reverseangle[@ 0]=0;
    //ds_list_clear(POWER_noangle[@ 1]); POWER_noangle[@ 0]=0;
    ds_list_clear(POWER_diagturn[@ 1]); POWER_diagturn[@ 0]=0;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}


//POWER_diagturn[@ 0] stuff
powerArray = POWER_diagturn;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    ds_list_clear(POWER_halfangle[@ 1]); POWER_halfangle[@ 0]=0;
    ds_list_clear(POWER_threehalfangle[@ 1]); POWER_threehalfangle[@ 0]=0;
    ds_list_clear(POWER_randomangle[@ 1]); POWER_randomangle[@ 0]=0;
    ds_list_clear(POWER_reverseangle[@ 1]); POWER_reverseangle[@ 0]=0;
    ds_list_clear(POWER_noangle[@ 1]); POWER_noangle[@ 0]=0;
    //ds_list_clear(POWER_diagturn[@ 1]); POWER_diagturn[@ 0]=0;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}



//POWER_slowpaddle[@ 0] stuff
powerArray = POWER_slowpaddle;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    //Tapper stuff
    if mouse_check_button_pressed(mb_left){
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/10;
       touchPadTap = true; 
    }
    
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}



//POWER_multistar[@ 0] stuff
powerArray = POWER_multistar;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] { //This may be a bad idea to mix with extra stars, we'll see.
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    
    //Tapper stuff
    if mouse_check_button_pressed(mb_left){
       powerTimer[| i] -= powerMaxDur * random_range(.05,.15);
       
       touchPadTap = true; 
       
       //Spawn Extra Star
       var obj = shooter_nearest_valid(centerfieldx,centerfieldy);
       if obj != noone{
            scr_popup_text_field_moving(obj.x,obj.y,'extra star!',COLORS[1])
            with (obj){
                 var copyFieldXY = convertGridtoXY(intGridXY[0], intGridXY[1]);
                 spawn_star(direction +choose(1,2,3)*90,copyFieldXY[0],copyFieldXY[1])
            }
        }
    }
    
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= max(1,scr_power_get_quick_deplete_value());
        //NB: We decrement this faster if there is already a lot of stars in play already.  Helps performance.
    
}



//POWER_addgrow[@ 0] stuff
powerArray = POWER_addgrow;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_subshrink;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8]

if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        powerArray[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
    paddleScale = true;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){


    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    
    //Tapper stuff
    if mouse_check_button_pressed(mb_left) and i == 0{ 
       powerArray[@ 7] += clamp( (1 - railCoverage*powerArray[@ 7]) *.1,.01,.05 )/railCoverage;
       with(paddle_id){
            padColorTimers[0] = max(
            padColorTimers[0],room_speed*.25)//.5
       }
       paddleScale = true;
       
       
       touchPadTap = true; 
    }
    
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        
        //Reset paddlesize
        if powerArray[@ 0] == 0{
           //tapper_PaddleSize = 1;
           powerArray[@ 7] = 1;
           paddleScale = true;
        }
    }
    else powerTimer[| i] -= max(1,scr_power_get_quick_deplete_value());
        //We decrement faster if board is overloaded
    
    
    
}


//POWER_subshrink[@ 0] stuff
powerArray = POWER_subshrink;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_addgrow;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        powerArray[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
    
   //Set Shrink
   powerArray[@ 7] = min(.05/railCoverage,.10);
   with(paddle_id){
        padColorTimers[2] = max(
        padColorTimers[2],room_speed*.5)//.5
   }
   paddleScale = true;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    //Tapper stuff
    if mouse_check_button_pressed(mb_left) and i == 0{
    
       //Decrement effect and timer, hybrid system
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/15;
       
       //Undecrease Paddle Size
       //POWER_subshrink[@ 7] += (1 - POWER_subshrink[@ 7])*.1;
       powerArray[@ 7] = min(.05/railCoverage,.10) * (powerTimer[| i] / powerMaxDur) +  
                                                 1 * (1 - powerTimer[| i] / powerMaxDur)
       with(paddle_id){
            padColorTimers[0] = max(
            padColorTimers[0],room_speed*.25)//.5
       }
       paddleScale = true;
       
       touchPadTap = true; 
    }


    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        
        //Reset paddlesize
        if powerArray[@ 0] == 0{
           //tapper_PaddleSize = 1;
           powerArray[@ 7] = 1;
           paddleScale = true;
        }
    }
    else powerTimer[| i] -= 1    
    
}





//POWER_addslower[@ 0] stuff
powerArray = POWER_addslower;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_subfaster;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        powerArray[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    
    //Tapper stuff
    if mouse_check_button_pressed(mb_left) and i == 0{ 
       
       //Decrease ShooterSpeed
       //tapper_ShooterSpeed += (.25 - tapper_ShooterSpeed)*.05;
       powerArray[@ 7] += (.25 - powerArray[@ 7])*.05;
       touchPadTap = true; 
       
    }
    
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        
        //Reset paddlesize
        if powerArray[@ 0] == 0{
           //tapper_ShooterSpeed = 1;
           powerArray[@ 7] = 1;
        }
    }
    else powerTimer[| i] -= 1
    
    
}



//POWER_subfaster[@ 0] stuff
powerArray = POWER_subfaster;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
antiPowerArray = POWER_addslower;
antiPowerTimer = antiPowerArray[@ 1];
antiPowerIndex = antiPowerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    var dur = powerMaxDur
    if antiPowerArray[@ 0] &gt; 0{
        for (var i = ds_list_size(antiPowerTimer) - 1; i &gt;= 0;i--){
            dur -= antiPowerTimer[| i];
            antiPowerTimer[| i] = 0;
            if dur &lt; 0{antiPowerTimer[| i] = antiPowerTimer[| i] - dur}
            if dur &lt;= 0{break}
        }
    }
    if dur &gt; 0{
        ds_list_insert(powerTimer,0,dur)
        cd_jiggle[powerIndex,0] = jiggletime;
    }
    else{ //else jiggle contra powerup
        powerArray[@ 0] -= 1;
        cd_jiggle[antiPowerIndex,0] = jiggletime;
    }
    
    //Set Speed Fast
    //tapper_ShooterSpeed = 1.6;
    powerArray[@ 7] = 1.6;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    
    //Tapper stuff
    if mouse_check_button_pressed(mb_left) and i == 0{
       //Decrement effect and timer, hybrid system
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/15;

       //Decrease ShooterSpeed
       powerArray[@ 7] += (1 - powerArray[@ 7])*.05;
       
       touchPadTap = true; 
    }
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        
        //Reset paddlesize
        if powerArray[@ 0] == 0{
           //tapper_ShooterSpeed = 1;
           powerArray[@ 7] = 1;
        }
    }
    else powerTimer[| i] -= 1;
}






//POWER_longerpowerups[@ 0] stuff
powerArray = POWER_longerpowerups;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
   
    
    //Tapper stuff
    if mouse_check_button_pressed(mb_left){
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/20;
       
       //Set Increase Dur Flag
       modifyDur = .1;
       touchPadTap = true; 
    }
     
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
}





//POWER_shorterpowerdowns[@ 0] stuff
powerArray = POWER_shorterpowerdowns;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

    //Tapper stuff
    if mouse_check_button_pressed(mb_left){
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/20;
       
       //Set Decrease Dur Flag
       modifyDur = -.2;
       touchPadTap = true; 
    }
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
}







//POWER_invertcontrols[@ 0] stuff
powerArray = POWER_invertcontrols;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

     //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    //Tapper stuff
    if mouse_check_button_pressed(mb_left){
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/10;
       
       touchPadTap = true; 
    }
    
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        
        //Reset Inverted Mouse Angle
        if powerArray[@ 0] == 0{
           powerArray[@ 7] = -1;
        }
        
    }
    else powerTimer[| i] -= 1
}






//POWER_multibonus[@ 0] stuff
powerArray = POWER_multibonus;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    //NB: We may want to use the multiplication sign as the symbol, we can enlarge it in inkscape.
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

     //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
     //Tapper stuff
    if mouse_check_button_pressed(mb_left){
    
       //Increment Combo Bonus
       global.pComboTimer = global.pComboTimerMax
       global.pComboCount += 1;
       global.pComboColor = 1//power_type_colors(1,0)
       
       //Decrement Timer
       powerTimer[| i] -= powerMaxDur/10;
       touchPadTap = true; 
    }
     
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;

    }
    else powerTimer[| i] -= 1
}




//POWER_multimalus[@ 0] stuff
powerArray = POWER_multimalus;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    //Disable Combo Bonus
    global.pComboTimer = 0
    
    //NB: We may want to use the division sign as the symbol, we can enlarge it in inkscape.
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){

     //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
     //Tapper stuff
    if mouse_check_button_pressed(mb_left){
    
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/10;
       touchPadTap = true; 
    }
    
    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
  
    }
    else powerTimer[| i] -= 1
}



//POWER_splitpaddle[@ 0] stuff
powerArray = POWER_splitpaddle;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    //ease to split
    if powerArray[@ 0] == 1{
        TweenFire(obj_control_game, property_splitsize, EaseLinear,
                TWEEN_MODE_ONCE, true, 0, 1, powerArray[7], 45/2); //ease to 90/4
    }
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    
     //Tapper stuff
    if mouse_check_button_pressed(mb_left){
       powerTimer[| i] = powerTimer[| i] - powerMaxDur/15;
       touchPadTap = true; 
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        
        //ease from split
        if powerArray[0] == 0{
            TweenFire(obj_control_game, property_splitsize, EaseLinear, 
                TWEEN_MODE_ONCE, true, 0,1, powerArray[7], 0);
        }

    }
    else powerTimer[| i] -= 1
    
}



//POWER_cashtap[@ 0] stuff
powerArray = POWER_cashtap;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;

}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    
    
     //Tapper stuff
    if mouse_check_button_pressed(mb_left){
       // Decrement Random Amount 
       //var decrementSize = irandom_range(5,20); 
       powerTimer[| i] = powerTimer[| i] - powerMaxDur * random_range(.05,.15);//decrementSize;
       touchPadTap = true; 
       
       // Add 1 cash per tap
       var cash_value = scr_starcash_power_caught(1);
       
       // Confetti Bomb
       var cash_text = "+$"+string(cash_value);
       //Maybe rng x/y would make more sense on touchpad?
       //var cash_x = mouse_x + RU * irandom_range(-1,1) * 10;
       //var cash_y = mouse_y + RU * irandom_range(-1,1) * 10;
       var cash_x = centerfieldx + RU * random_range(-1,1) * GAME_W * .35;
       var cash_y = centerfieldy + RU * random_range(-1,1) * GAME_W * .35;
            //NB: We rng a bit off the mouse so people see they're getting more than $1
       scr_create_confetti(cash_x, cash_y, 32, 32, 1);
       scr_popup_text_zoomup(cash_x,cash_y,cash_text,COLORS[3], fnt_reward_cash_game, false, 3*room_speed)
       scr_sound(sd_catch_cash, 1, false); //maybe redundant with click sound?
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;


    }
    else powerTimer[| i] -= 1
    
}


//POWER_offsetpaddle[@ 0] stuff
powerArray = POWER_offsetpaddle;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
    
    // Get New Offset
    var newOffset = choose(90,180,-90);
    // Ease Misc Val to New Offset
    TweenFire(obj_control_game, property_offsetpaddle, EaseLinear, 
        TWEEN_MODE_ONCE, true, 0, 1, powerArray[7], newOffset);


}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    // Decrement Timer
    if powerTimer[| i] &lt;= 0{
        // Delete Timer if Complete
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
        // Ease Back Offset to 0
        if powerArray[@ 0] &lt;= 0{
            TweenFire(obj_control_game, property_offsetpaddle, EaseLinear, 
                TWEEN_MODE_ONCE, true, 0, 1,  powerArray[7], 0);
        }
    }
    else powerTimer[| i] -= 1
    
}


//POWER_cashx2[@ 0] stuff
powerArray = POWER_cashx2;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8]
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;

}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }
    // Decrement Timer
    if powerTimer[| i] &lt;= 0{
        // Delete Timer if Complete
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;
    }
    else powerTimer[| i] -= 1
    
}
    
    


//POWER_density_doubler[@ 0] stuff
powerArray = POWER_density_doubler;
powerTimer = powerArray[@ 1];
powerMaxDur = powerArray[@ 2];
powerIndex = powerArray[@ 8];
if powerArray[@ 0] &gt; ds_list_size(powerTimer){
    ds_list_insert(powerTimer,0,powerMaxDur)
    cd_jiggle[powerIndex,0] = jiggletime;
}
for (var i = ds_list_size(powerTimer) - 1; i &gt;= 0;i--){
    
    //Modify Duration
    if abs(modifyDur) == powerArray[@ 3] {
       powerTimer[| i] += sign(modifyDur)*powerMaxDur/10;
    }

    if powerTimer[| i] &lt;= 0{
        ds_list_delete(powerTimer,i)
        powerArray[@ 0] -= 1;

    }
    else powerTimer[| i] -= 1
    
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Duration Timers, Tapper Text



if !GAMEOVER {
    
    icon_width = 75;
    icon_height = 60;
    var _timer_width = scr_sum_powers();
    
    
    
    if _timer_width &gt; 0
    {
        var _timersx, _timersy, adj__timersx, adj__timersy, _timerval, ii;
        _timersx = centerfieldx;//GAME_X +GAME_W/2;
        
        //if TUTORIAL_ENABLED and instance_exists(obj_board_modifier_dummy) {
       //    _timersy = obj_board_modifier_dummy.mixers_y;}
       // else _timersy = global.texty+15;
        
        _timersy = mixers_y[mixPos[0]] -icon_height/2;
        adj__timersx = _timersx-_timer_width*icon_width/2
        adj__timersy = _timersy
        _timerval = 0
        ii = 0 //iterator for _timer width
    
        draw_set_font(fnt_gui_counts3)
        draw_set_valign(fa_middle)
        draw_set_halign(fa_center)
    
        for (var z = 0, n = array_length_1d(POWER_ARRAY); z &lt; n; z++){
    
            CurrentPower = POWER_ARRAY[z];
            CurrentPowerTimer = CurrentPower[1];
            if ds_list_size(CurrentPowerTimer) &gt; 0
            {  
                //Get MetaData
                CurrentPowerCount = CurrentPower[0];
                CurrentPowerTimerMaxDur = CurrentPower[2];
                CurrentPowerType = CurrentPower[3];
                CurrentPowerSprite = CurrentPower[4];
                CurrentPowerText = CurrentPower[5];
                CurrentPowerTapText = CurrentPower[6];
                
                //Set Val
                _timerval = clamp(CurrentPowerTimer[| 0]/CurrentPowerTimerMaxDur,0,1);
                //Set Coordinates
                iconx1 = adj__timersx +ii*icon_width + cd_jiggle[z,1];
                icony1 = adj__timersy + cd_jiggle[z,2];
                iconx2 = adj__timersx +(ii+1)*icon_width + cd_jiggle[z,1];
                icony2 = adj__timersy+icon_height + cd_jiggle[z,2];
                
                //Set Colors
                icon_col = power_type_colors(CurrentPowerType,0);
                sym_color = power_type_colors(CurrentPowerType,1);
                
                //Draw Power Icon
                draw_rectangle_cd_barfill_icon_sprite(iconx1, icony1, iconx2, icony2, _timerval,
                CurrentPowerCount,CurrentPowerSprite, icon_col, sym_color)
                //Draw Description Text
                if cd_jiggle[z,3] &gt; 0{ // timer var
                    draw_set_font(fnt_gui_counts2)
                    draw_text_colour((iconx1+iconx2)/2,icony2+16,CurrentPowerText,
                    COLORS[0],COLORS[0],COLORS[0],COLORS[0],1)
                }   
                    
                
                //Set Tapper Dialoue Text
                if CurrentPowerTapText != "" and tap_text_index &lt; n-z{
                   tap_text_index = n-z;
                   tap_col = icon_col;
                   tap_timerval = _timerval;
                   tap_text = CurrentPowerTapText;
                }
                
                ii++
            }
        }
        
    }
    
    
    //Tap Text Dialogue
    if tap_text_index &gt;= 0{
        if touchPadTap {
            // Ease Text Scale A Bit
            if TweenExists(touchPadTapTween){
                TweenDestroy(touchPadTapTween);
            }
            // Reset Ease
            touchPadTapEase[0] = 1;
            touchPadTapTween = TweenFire(id, touchPadTapEase,EaseLinear,
                                 TWEEN_MODE_BOUNCE, true, 0,.1, touchPadTapEase[0], 1.2);
                                    //touchPadTapEase[0]
                                        //We may want to do two chained tweens here.. not sure.
                                            //We'd schedule it in that case.
            //TweenPlayBounce(touchPadTapTween)
            //TweenDestroyWhenDone(touchPadTapTween,true, false)
            // Play Tap Sound
            scr_sound(sd_menu_click);
            touchPadTap = false;
        }
           
        txt_font = fnt_menu_in_game;//fnt_powerups; 
        draw_set_font(txt_font)
        txt_height = (string_height("H")*.6 + string_height(tap_text) * .5) * touchPadTapEase[0];
        scr_draw_text_tap_dialogue(centerfieldx,centerfieldy+txt_height,
        tap_text,touchPadTapEase[0],tap_col, 1, txt_font, true); //max(.5,tap_timerval)
        
        
        
        tap_text_index = -1;
        
    } 
    /*
    // Clear Touch Tap Flag
    else if touchPadTap {
        touchPadTap = false;
    
    }*/
    
    
    
    
    //Decrement icon jigglers
    var jiggle_strength = 4;
    for (var i=0, n = array_height_2d(cd_jiggle); i &lt; n; i++){ 
        //Decrement Jiggler
        if cd_jiggle[i,0] &gt; 0{
            cd_jiggle[i,0] -= 1
            cd_jiggle[i,1] = random_range(-1,1)*jiggle_strength;
            cd_jiggle[i,2] = random_range(-1,1)*jiggle_strength;
            //Set description text duration
            if cd_jiggle[i,0] &gt;= jiggletime-1 {cd_jiggle[i,3] = defaultPowerDuration}//jiggletime*8}
        }
        //Disable Jiggles
        else if cd_jiggle[i,0] &gt;= -1{
            cd_jiggle[i,0] = -2
            cd_jiggle[i,1] = 0;
            cd_jiggle[i,2] = 0;
        
        }
        //Decrement display text
        if cd_jiggle[i,3] &gt; 0{
            cd_jiggle[i,3] -= 1
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///debug
/*
draw_text_colour(mouse_x,mouse_y,'rOL='+string(railOverload),c_blue,c_blue,c_blue,c_blue,1)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>10,10</point>
  </PhysicsShapePoints>
</object>
