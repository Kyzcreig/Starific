<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Ini tween/menu vars
//LAST_ROOM = rm_game

//Tween Vars


s_selected[0] = noone;
s_selected[1] = true;

//Array to hold graduated menu slides
mainSchedule = 0;
mainEase[0] = 0
//Tweens
mainTween = TweenFire(id, mainEase,EaseLinear,
                    TWEEN_MODE_ONCE,true,0,1,0,2);
subEase[12] = 0;


ini_open("savedata.ini");
    // STATS_PAGE Data
    s_CurrentMode = ini_read_real("settings", "s_CurrentMode", 0); //default to arcade mode
    s_CurrentSize = ini_read_real("settings", "s_CurrentSize", 0); //default to 25x25 size
    //s_CurrentRigor = ini_read_real("settings", "s_CurrentDiff", 0); //default to beginner unused
    //s_CurrentScope = ini_read_real("settings", "s_CurrentScope", 0); //default to local unused for time scoping
ini_close();



title_font = fnt_menu_title_95; 
title_txt = "stats";


// Menu Modes Options
for (var i = 0; i &lt; 4; i++){
    var data = scr_unlock_get_data(1,i);
    s_Modes[i] = data[5];
    // If Locked
    if data[1] == 0 {
        // Obfuscate text
        s_Modes[i] = scr_cypher_text("abcdefghijklmnopqrstuvwxyz","?",s_Modes[i]);
    
    } 
}
s_CurrentMode = clamp(s_CurrentMode,0,array_length_1d(s_Modes)-1)




// Menu Size Options
for (var i = 0; i &lt; 4; i++){
    var key = scr_unlock_get_key(0,i);
    var data = UNLOCKS_DATA[? key];
    //s_Size[w] = data[5];
    s_Size[i] = string(convert_index_to_grid(i)) + " x "
               +string(convert_index_to_grid(i));
    if data[1] == 0 {
        s_Size[i] =  scr_cypher_text("0123456789","?",s_Size[i]);   
    }
}
   
s_CurrentSize = clamp(s_CurrentSize,0,array_length_1d(s_Size)-1)

s_adj = 0 //used for modulus rotation of stat filters


// Main Heading TEXT  ------------
s_menu[0] = 'stats'
s_menu[1] = s_Modes[s_CurrentMode] 
//for color I can use the color array and currentMode+1 as index
s_menu[2] = s_Size[s_CurrentSize]


//STAT GROUP HEADLINES
s_group[0] = 'best'
s_group[1] = 'recent'
s_group[2] = 'career'
s_group[3] = 'average'





image_speed = 0
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///pull stats into arrays

ini_open("scores.ini")
for (var m = 0, mt = array_length_1d(s_Modes); m &lt; mt; m++){
    for (var g= 0, gt = array_length_1d(s_Size); g &lt; gt; g++){
        
        var currentSection = scr_stats_get_section(m,g, 0);//"Stats_"+string(m + g*mt);
        
        gamesPlayed[m,g] =ini_read_real(currentSection, "gamesPlayed", 0);
        
        highScore[m,g] =ini_read_real(currentSection, "highScore", 0);
        careerScore[m,g] =ini_read_real(currentSection, "careerScore", 0);
        lastScore[m,g] =ini_read_real(currentSection, "lastScore", 0);
        averageScore[m,g] =ini_read_real(currentSection, "averageScore", 0);
        
        careerLevel[m,g] =ini_read_real(currentSection, "careerLevel", 0);
        highLevel[m,g] =ini_read_real(currentSection, "highLevel", 0);
        lastLevel[m,g] =ini_read_real(currentSection, "lastLevel", 0);
        averageLevel[m,g] =ini_read_real(currentSection, "averageLevel", 0);
        
        longestStreaksTotal[m,g] =ini_read_real(currentSection, "longestStreaksTotal", 0);
        longestStreak[m,g] =ini_read_real(currentSection, "longestStreak", 0);
        lastLongestStreak[m,g] =ini_read_real(currentSection, "lastLongestStreak", 0);
        averageLongestStreak[m,g] =ini_read_real(currentSection, "averageLongestStreak", 0);
        
        careerReflects[m,g] =ini_read_real(currentSection, "careerReflects", 0);
        highReflects[m,g] =ini_read_real(currentSection, "highReflects", 0);
        lastReflects[m,g] =ini_read_real(currentSection, "lastReflects", 0);
        averageReflects[m,g] =ini_read_real(currentSection, "averageReflects", 0);
        
        careerPlaytime[m,g] =ini_read_real(currentSection, "careerPlaytime", 0);
        longestPlaytime[m,g] =ini_read_real(currentSection, "longestPlaytime", 0);
        lastPlaytime[m,g] =ini_read_real(currentSection, "lastPlaytime", 0);
        averagePlaytime[m,g] =ini_read_real(currentSection, "averagePlaytime", 0);
        
        careerDeaths[m,g] =ini_read_real(currentSection, "careerDeaths", 0);
        lastDeaths[m,g] =ini_read_real(currentSection, "lastDeaths", 0);
        averageDeaths[m,g] =ini_read_real(currentSection, "averageDeaths", 0);
        
        highestPPD[m,g] =ini_read_real(currentSection, "highestPPD", 0);
        lastPPD[m,g] =ini_read_real(currentSection, "lastPPD", 0);
        averagePPD[m,g] =ini_read_real(currentSection, "averagePPD", 0);
        
        highestRPD[m,g] =ini_read_real(currentSection, "highestRPD", 0);
        lastRPD[m,g] =ini_read_real(currentSection, "lastRPD", 0);
        averageRPD[m,g] =ini_read_real(currentSection, "averageRPD", 0);
        
        careerBestComboTotal[m,g] =  ini_read_real(currentSection, "careerBestComboTotal", 0);
        highestBestCombo[m,g] = ini_read_real(currentSection, "highestBestCombo", 0);
        lastBestCombo[m,g] = ini_read_real(currentSection, "lastBestCombo", 0);
        averageBestCombo[m,g] = ini_read_real(currentSection, "averageBestCombo", 0);
        
        careerDCatches[m,g] = ini_read_real(currentSection, "careerDCatches", 0);
        highestDCatches[m,g] = ini_read_real(currentSection, "highestDCatches", 0);
        lastDCatches[m,g] = ini_read_real(currentSection, "lastDCatches", 0);
        averageDCatches[m,g] = ini_read_real(currentSection, "averageDCatches", 0)
        
        careerSCatches[m,g] = ini_read_real(currentSection, "careerSCatches", 0);
        highestSCatches[m,g] = ini_read_real(currentSection, "highestSCatches", 0);
        lastSCatches[m,g] = ini_read_real(currentSection, "lastSCatches", 0);
        averageSCatches[m,g] = ini_read_real(currentSection, "averageSCatches", 0)
        
        careerStars[m,g] = ini_read_real(currentSection, "careerStars", 0);
        highestStars[m,g] = ini_read_real(currentSection, "highestStars", 0);
        lastStars[m,g] = ini_read_real(currentSection, "lastStars", 0);
        averageStars[m,g] = ini_read_real(currentSection, "averageStars", 0)
        
        careerStarsSaved[m,g] = ini_read_real(currentSection, "careerStarsSaved", 0);
        highestStarsSaved[m,g] = ini_read_real(currentSection, "highestStarsSaved", 0);
        lastStarsSaved[m,g] = ini_read_real(currentSection, "lastStarsSaved", 0);
        averageStarsSaved[m,g] = ini_read_real(currentSection, "averageStarsSaved", 0)

    }
}
ini_close();

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Additional stat manipulation

for (var m= 0; m&lt;array_length_1d(s_Modes);m++){
    for (var g= 0; g&lt;array_length_1d(s_Size);g++){
    
        //Format playtimes
        formatted_careerPlaytime[m,g] = time_decode_custom(careerPlaytime[m,g],60);
        formatted_longestPlaytime[m,g] = time_decode_custom(longestPlaytime[m,g],60);
        formatted_lastPlaytime[m,g] = time_decode_custom(lastPlaytime[m,g],60);
        formatted_averagePlaytime[m,g] = time_decode_custom(averagePlaytime[m,g],60);
        
        //Format save percentage
        formatted_careerStarsSaved[m,g] = string_format(careerStarsSaved[m,g]*100,1,2);
        formatted_highestStarsSaved[m,g] = string_format(highestStarsSaved[m,g]*100,1,2); 
        formatted_lastStarsSaved[m,g] = string_format(lastStarsSaved[m,g]*100,1,2); 
        formatted_averageStarsSaved[m,g] = string_format(averageStarsSaved[m,g]*100,1,2); 
        
    }
}

image_speed = 0

/*
cH[m,g] = string(careerPlaytime[m,g] div 3600);
while string_length(cH[m,g]) &lt; 2{cH[m,g] = '0'+cH[m,g];}
cM[m,g] = string((careerPlaytime[m,g] mod 3600) div 60);
while string_length(cM[m,g]) &lt; 2{cM[m,g] = '0'+cM[m,g];}
cS[m,g] = string(careerPlaytime[m,g] mod 60);
while string_length(cS[m,g]) &lt; 2{cS[m,g] = '0'+cS[m,g];}

lH[m,g] = string(lastPlaytime[m,g] div 3600);
while string_length(lH[m,g]) &lt; 2{lH[m,g] = '0'+lH[m,g];}
lM[m,g] = string((lastPlaytime[m,g] mod 3600) div 60);
while string_length(lM[m,g]) &lt; 2{lM[m,g] = '0'+lM[m,g];}
lS[m,g] = string(lastPlaytime[m,g] mod 60);
while string_length(lS[m,g]) &lt; 2{lS[m,g] = '0'+lS[m,g];}

aH[m,g] = string(averagePlaytime[m,g] div 3600);
while string_length(aH[m,g]) &lt; 2{aH[m,g] = '0'+aH[m,g];}
aM[m,g] = string((averagePlaytime[m,g] mod 3600) div 60);
while string_length(aM[m,g]) &lt; 2{aM[m,g] = '0'+aM[m,g];}
aS[m,g] = string(averagePlaytime[m,g] mod 60);
while string_length(aS[m,g]) &lt; 2{aS[m,g] = '0'+aS[m,g];}*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Online Leaderboards [unused]

/*
We want to add leaderboards for each mode and size and for weekly and all time.  Gosh it would be a lot cleaner if I did this with my own database though.  Definitely a good project idea for the future.
Then add a leaderboards button to main menu.

if achievement_available(){
    achievement_show_leaderboards();
}
else{
//to do show dialogue saying to log into gamecenter//change text according to platform of course.

}



NB: I'd like to use my own service for this ultimately, 
maybe also using your gamecenter or google play username or a custom user name system 
like I described in trello.  Where it would request a name only once you look at stats 
or in the settings page.
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Scroll Init

scr_page_scroll_init();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Return to Menu
ScheduleScript(obj_control_main,0,1,scr_room_goto,rm_menu);

//TweenOnFinishAdd(mainTween,id,scr_room_goto,rm_menu);//LAST_ROOM
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Scroll Cleanup


scr_page_scroll_cleanup();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Select Stat Choices

/*

scr_assert_menuSurface_exists()
//surface_reset_target()
surface_set_target(global.menuSurface);
// If Popup prompt is in play
if popup_page[0] != 0 {
    draw_clear_alpha(COLORS[7],0);  // 0 alpha makes text more legible
}
else {
    draw_clear_alpha(COLORS[7],1);  // 1 alpha is needed to make popups look good
}



//Reset surface draw
scr_settings_page_footer();


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stats Menu Choices

/*
        s_TweenSlide3 = TweenFire(id, s_SlideTween3,false,EaseLinear,1,0,room_speed/2);
        s_TweenSlide2 = TweenCreate(id, s_SlideTween2,false,EaseOutBack,1,0,room_speed/2);
        s_TweenSlide1 = TweenCreate(id, s_SlideTween1,false,EaseOutBack,1,0,room_speed/2);
        s_TweenFade = TweenCreate(id, s_FadeTween,false,EaseLinear,.75,0,room_speed/2);
        TweenOnFinishAdd(s_TweenSlide3,id,TweenPlayOnce,s_TweenSlide2)
        TweenOnFinishAdd(s_TweenSlide2,id,TweenPlayOnce,s_TweenSlide1)
        TweenOnFinishAdd(s_TweenSlide1,id,TweenPlayOnce,s_TweenFade)
        */

switch s_selected[0]
{
    //Stats Mode Arrow Selected
    case 1: 
        s_CurrentMode = (s_CurrentMode + s_adj) mod array_length_1d(s_Modes)
        
        //Save menu selection
        ini_open("savedata.ini")
           ini_write_real("settings", "s_CurrentMode", s_CurrentMode);
        ini_close()
        
        s_selected[0] = noone;
    break;
    //Stats Size Arrow Selected
    case 2: 
        s_CurrentSize = (s_CurrentSize + s_adj) mod array_length_1d(s_Size)
        
        //Save menu selection
        ini_open("savedata.ini")
           ini_write_real("settings", "s_CurrentSize", s_CurrentSize);
        ini_close()
        
        s_selected[0] = noone;
    break;
   
   
 

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy

instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///STATS DISPLAY
scr_menu_draw_stats()

/*
scr_page_draw_surface(global.menuSurface)







</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
