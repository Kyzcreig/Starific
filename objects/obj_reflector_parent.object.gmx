<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_v_deflector_basic</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init vars

gridXY = convertXYtoGrid(x,y);

/*
if DENSITY != 0{
    //scr_field_set(gridXY[0], gridXY[1],1, id); 
    global.FIELD_OBJECTS[# gridXY[0], gridXY[1]] = id;
}*/


//DRAW RELATED VARS
depth = 100000; //this is needed so child objects have the right depth
visible = true;
//depth = 100002

//Direction shooter will turn on collision
rdir = choose(90,-90);//choose(45,-45);


//STATE VARS
destroyer = noone;
mutliplier = 1;
ndir = 0;
odir = 180;
spe = 0;

//Bomb State Vars
bomb = false;
bomber = noone;
bomb_ndir = ndir;
bomb_odir = odir;

// Star Modifier Data
scr_reflector_init_star_modifiers();


// Beater Instance
instance_beater = noone;

//Board Clear 
boardClear = false;

//Particle effect
particleDeath = true;





   
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set types and drawing


objData = scr_deflector_get_data(object_index);
//NB: This would cause errors if we spawned stuff not in the map e.g. parents.
//  But we could always add the parent objects too.

//Set Object Type and Sprite
objType = scr_deflector_set_draw_type(objData);
sprite_index = object_get_sprite(scr_deflector_get_direct_parent(objType));
                    //The above script also overrides obj type for parents

  
//Set Sprite Params
image_speed = 0;//images cycled per STEP
//for masks to work i need precision collision on
mask_index = sp_reflector_mask;
//sprite_index = sp_reflector_basic_red
oScale = cellH/sprite_get_width(sprite_index);
image_xscale = oScale;//objectScale
image_yscale = oScale;//objectScale



//Set Symbol and Colors (and GameMods if active)
event_perform(ev_other,ev_user1)
               

//Set Symbol and Scale Offsets
symScale = cellW/60 //*1.25;
symScaleStart = 0; // used for easing deflector scale
symScaleStart = symScale;
symOffsetX = 0;
symOffsetY = 0;


/*
// Set Offsets for Certain Symbols (To make them look better)
//Uppers
if objType == 1
{
   if object_index == obj_powerup_growpaddle or 
      object_index == obj_powerup_slower
   {
        symOffsetY = 2.5 * symScale;
   }

}
//Downers
else if objType == 2
{
   if object_index == obj_powerup_shrinkpaddle or 
      object_index == obj_powerup_faster
   {
        symOffsetY = -2.5 * symScale;
   }
}




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///spawn special effects

// Init Tween
tweenSpawn = noone

//Spawn Tween
if DENSITY &gt; 0 {
    // Cool Intro Animation
    if !MOVE_ACTIVE and BOARD_INIT_COUNT &lt; 1{
       introspawn(INTRO_ANGLE, INTRO_RAD, INTRO_DIST, INTRO_DUR,INTRO_EASE)
    }
    // Quick Blur-In 
    else{
       tweenSpawn = TweenFire(id,reflectorScale__,EaseLinear,
                        TWEEN_MODE_ONCE,1,0,.5, 0,1)
       //TweenDestroyWhenDone(tweenSpawn,true);
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_spawn,image_blend,1);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy (realloc to pool)

event_perform(ev_other,ev_user15);

/*

add grid cell to empties and particle effect
if (MOVE_ACTIVE == true){
    scr_field_empty_add(gridXY); 
}

if particleDeath{ 
    var pDensity = scr_particle_explosion_count(boardClear);
    
    //if not basic or bomb, do special effect
    if objType != 0 and objType != 4{
       pDensity = round(pDensity * 2);
       //part_type_orientation(p_destroy_ring_long,0,359,random_range(-2.5,2.5),0,1); //rangerandom(-2,2);
       part_type_orientation(p_destroy_ring_long,0,359,0,0,1); //rangerandom(-2,2);
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_sparkles_long, c_part, pDensity);//1
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_ring_long, c_part,1);
    }
    //else regular effect
    else{
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_sparkles, c_part, pDensity);//1
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_ring, c_part,1);
    }
    
    //part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_sparkles, c_part, pDensity);//1
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Realloc Object, Add to Empty List and Particle Death Effect
if (MOVE_ACTIVE == true){
    scr_field_empty_add(gridXY); 
}

if particleDeath{ 
    // How many particles
    var particleCount = scr_particle_explosion_count(boardClear);
    
    //if not basic or bomb, do special effect
    if objType != 0 and 
       objType != 4 and 
       GAME_ACTIVE  //EVALUATE ME (makes effects all the same size)  
    {
       particleCount *= 2;//round()
       //part_type_orientation(p_destroy_ring_long,0,359,random_range(-2.5,2.5),0,1); //rangerandom(-2,2);
       part_type_orientation(p_destroy_ring_long,0,359,0,0,1); //rangerandom(-2,2);
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_sparkles_long, image_blend, particleCount);//1
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_ring_long, image_blend,1);
    }
    //else regular effect
    else{
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_sparkles, image_blend, particleCount);//1
       part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_ring, image_blend,1);
    }
    
    //part_particles_create_color(PSYS_FIELD_LAYER, x, y, p_destroy_sparkles, c_part, pDensity);//1
}

// Realloc Object to Pool
x = -100; y = -100;
if  RESOURCE_POOLING {
    instance_change(obj_deflector_pool,true);
} else {
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set Aesthetics

scr_deflector_set_aesthetics();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///On Star Collision
//maybe i need to have a variable such that this is only called once
if (MOVE_ACTIVE){//THIS IS TRUE AS SOON AS A SHOOTER EXISTS
   
    //Clear grid val
    //gridXY = convertXYtoGrid(x,y);
    global.FIELD_OBJECTS[# gridXY[0], gridXY[1]] = noone;    


    //Grab state variables
    scr_set_reflector_vars_from_shooter(bomb,true);
    
    //Add points
    var added = 1;//pts
    if !boardClear {scr_raw_score_add(added);}
    if scr_gamemod_get_index("ultra_points", 8) &gt; 0 {
        added *= scr_gamemod_get_index("ultra_points", 10);
    }
    // Calculate Points
    added = scr_calculate_points(added);   
    score_p1 += added;
    lastPPD += added;
    //time_left += added;
    
    
    if !bomb or objType != 0{
       scr_collision_sound();
    }
    
    
    image_xscale = 0;
    image_yscale = 0;
    
    
    
       

    //DESTROY
    //empties added in death event
    //ScheduleScript(id,false,1,Destroy,id) //Does this add lag?
    //instance_destroy();
    alarm[0] = 1;
    
    //Death Tween
    /*tweenDeath = TweenSimpleScale(image_xscale,image_yscale,0,0,room_speed*.5,EaseLinear)
    TweenOnFinishAdd(tweenDeath, id, Destroy, id);
    TweenDestroyWhenDone(tweenDeath,true);*/
    
    
    //Increment Death count
    with(obj_control_modifiers){
        var objData = other.objData;
        
        scr_deflector_add_stat(objData,6);
        
        //If Moves Mode 
        if MODE == MODES.MOVES {
            var parentIndex = scr_deflector_get_direct_parent(objData[1]);
            var parentData = scr_deflector_get_data(parentIndex);
            var mType = objData[1]+1; //objType offset by 1 for modifiers array
            //Check if Enough Board Modifiers for +1
            if (parentData[6] &gt;= boardMixers[mType,5] ){  //modulo is an option but it's excessive computation
                //Increment Board Modifiers       
                boardMixers[mType,0] += 1;
                
                //Move Data from Current Counter to Total Counter, for efficiency
                parentData[@ 6] -= boardMixers[mType,5];
                parentData[@ 7] += boardMixers[mType,5];
                
                //Set GUI jiggler
                //bMjiggle[mType,0] = bMjiggletime*1//.5
               
                //Dialogue text on increment
                txt_font = fnt_game_bn_40_bold//fnt_menu_bn_40_bold;//; 
                draw_set_font(txt_font);
                txt_text = "+1 "+string_replace(boardMixers[mType,3],"#"," ");
                txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
                txt_col = power_type_colors(boardMixers[mType,1],0); //return colors based on type between 0-4
                //txt_col = power_type_colors(-1,boardMixers[mType,1]); //return colors based on type between 0-4
                                        //NB: we do this to avoid using the basic deflector color for +1 boardfill, it's hard to read
                scr_popup_text_field_static(centerfieldx,centerfieldy+txt_height,
                txt_text,txt_col,txt_font, true, 3*room_speed);
            }
        }
    
    }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
