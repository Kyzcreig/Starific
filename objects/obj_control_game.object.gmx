<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Game Init (keep at top)

globalvar cellSize, cellW, cellH, ox, oy,  gridSize, fieldW, fieldH, corner;
globalvar MOVE_ACTIVE, GAME_ACTIVE, BOARD_INIT_COUNT, MOVE_COUNT;
globalvar SPAWN_COUNTER, empties,emptylaneX,emptylaneY;//, refdir;
globalvar centerfieldx, centerfieldy, DENSITY;
globalvar railset,roundPlaytime, objectScale;
globalvar INTRO_DUR, INTRO_ANGLE, INTRO_RAD, INTRO_DIST, INTRO_EASE;
globalvar fieldSat, fieldSet, fieldDensity, powerDensity, BOARD_TOTAL;//, BOARD_FILL;
globalvar BOMB_DELAY_SCALAR;
//globalvar FIELD_DEBUGGER;

// Set Field Debug Text
//FIELD_DEBUGGER = 0;

ini_open("scores.ini")
    //gridSize = 20//15//16//25
    GRID = ini_read_real("settings", "GRID", 0);
    GRID = clamp(GRID,0,3);
    RIGOR = ini_read_real("settings", "RIGOR", 0);
    //scr_button_update_indicator( scr_unlock_get_data( 0,convert_grid_to_index(gridSize) ) );
    //scr_mark_rigor_as_seen(RIGOR)
ini_close();


//Load Stats
scr_stats_load() //keep below gridSize load, since we use that here

GAMEOVER = false;
MOVE_ACTIVE = false;
GAME_ACTIVE = false;
BOARD_INIT_COUNT = 0
BOARD_TOTAL = 0
//BOARD_FILL = 0;
SPAWN_COUNTER = 0;
MOVE_COUNT = 1;
emptylaneX = noone;
emptylaneY = noone;


// Set Field Params
global.FIELD_EMPTIES_SIZE = GRID+3;
gridSize = convert_index_to_grid(GRID);
fieldW = gridSize//16//25;
fieldH = gridSize//16//25;
//Init Deflector Death Map
scr_death_timers_init();

//Field Params
var fDensities; //.525-.005*gridSize
fDensities[0] = .45;
fDensities[1] = .425;
fDensities[2] = .40;
fDensities[3] = .375;
fieldDensity = (fDensities[GRID])+ .05*(MODE == MODES.MOVES)// //.075
//fieldDensityThreshold = fieldDensity * 1.2;
fieldSat = 1;
fieldSet = true;


var pDensities;
pDensities[0] = .20;
pDensities[1] = .15;
pDensities[2] = .125;
pDensities[3] = .12; //EVALUATE THIS
powerDensity = pDensities[GRID] 
// Scale up power DENSITY for higher difficulties
powerDensity *= ( 1 + RIGOR * .025)
    //I like the current 0 difficulty gameplay.  I wonder if higher difficulties are good then
// Scale up for moves mode
powerDensity *=  (1 +.35 * (MODE==MODES.MOVES));

cellSize = scr_field_calc_cellSize(gridSize) 
//cellSize = ceil(420 / gridSize)

cellW = cellSize//32// ; // set the width of a single cell
cellH = cellSize//32//sprite_get_height(sp_reflector_basic); // set the height of a single cell

objectScale = cellSize/sprite_get_width(s_v_deflector_basic)//sp_reflector_basic)


//paddle_id = 0

railset = scr_field_calc_railBuffer(gridSize)
corner = scr_field_calc_cornerSize(gridSize) 
nullCells = (corner + 1) * corner / 2 //closed form of SUM 0-&gt;corner;
/*
for (i = 0; i &lt; corner; i++){
    nullCells += corner - i
}*/




//Set Room Parameters
if GAME_ACTIVE == false and NEW_GAME == true{


    // Set Game Init State
    GAME_ACTIVE = true;
    NEW_GAME = false

    // Board Params
    BOARD_TOTAL = fieldW*fieldH - nullCells*4
    
    // Game Field Resize
    scr_grid_data_init()
    var field_origin = scr_field_calc_origin(gridSize, cellSize);
    ox = field_origin[0];
    oy = field_origin[1];
    
    //centerfieldx = room_width*.5
    //centerfieldy = (room_height*2/3)*.5
    
    var field_center = scr_field_calc_center(ox, oy, gridSize, cellSize);
    centerfieldx = field_center[0];
    centerfieldy = field_center[1];
    
    
    // Get Magnitude of Instance IDs
    DENSITY = 0;
    with (instance_create(-100,-100,obj_reflector_parent)){//(obj){
         if DENSITY == 0{
            //Set Density to whatever power of 10 GMS is using for instance indexes
            DENSITY = power(10,round(log10(id)));
            instance_destroy()
         }
    }
    
    // If Resource Pooling
    if RESOURCE_POOLING {
        // Clear Field Pool
        ds_queue_clear(global.FIELD_POOL);
        with (obj_deflector_pool) {instance_destroy()};
        // Create all the pool objects so memory is allocated only once
        for (var i = 0; i &lt; BOARD_TOTAL; i++){
            //ds_queue_enqueue(global.FIELD_POOL ,instance_create(-100,-100,obj_deflector_pool));
            instance_create(-100,-100,obj_deflector_pool);
        }
        // Clear Beater Pool
        ds_queue_clear(global.BEATER_POOL);
        with (obj_beat_pool) {instance_destroy()};
        // Create all the pool objects so memory is allocated only once
        for (var i = 0; i &lt; BOARD_TOTAL*2; i++){
            //ds_queue_enqueue(global.BEATER_POOL,instance_create(-100,-100,obj_beat_pool));
            instance_create(-100,-100,obj_beat_pool);
        }
    }
    
    
    // Set Wait on Additional Spawning of 2 Seconds
    spawnDelay = room_speed*2;
    
    
    BOMB_DELAY_SCALAR = room_speed *.5 / gridSize;
    
    
    // Set Spawn Chances for Deflectors
    scr_spawner_chance_init();
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Gamemode Init
   
//Game stuff
globalvar
score_p1,
score_p2,
score_p3,
score_p4,
score_display,
roundStep, 
level, 
levelUp, 
levelScore,
levelScoreStart,
levelDiffAdj,
MOVES_REMAINING, 
moves_time_active,
time_left, 
time_penalty,
time_decrement,
RIGOR_MULTIPLIER;




global.ActiveStarCount = max(1,instance_number(obj_star));



//Round Init
MOVE_READY = false;
alarm[0] = -1


//RIGOR
RIGOR_MULTIPLIER = convert_index_to_rigor(RIGOR);
levelDiffAdj = logn(2,gridSize) / logn(2,25)//gridSize / 25;
    //One way to make this more sensitive to gridSize is to scale down the quotient
    // E.G. levelDiffAdj = logn(2,gridSize/5) /logn(2,25/5)//gridSize / 25;

//ARCADE
lives = 1;
level = 1;
levelUp = false
lastLevelScore = 0.0
levelScoreStart = 100 * levelDiffAdj//logn(2,gridSize) /logn(2,25)// (1 + 9*(MODE == 2))
//levelScoreStart = .16 * sqr(gridSize)// (1 + 9*(MODE == 2))
levelScore = levelScoreStart //* (1+(.25*(level-1)))

//show_message("levelScore="+string(levelScore));

//old level up effect vars
levelUp_alpha = 0 //alpha for level up effect
text = ''


//TIME
//c_time = COLORS[6]//c_ gui
tstep = 0
time_elapsed = 0
time_left = room_speed//30*room_speed
time_decrement = time_left / (30*room_speed)//(1 + .1*level) + .1 * time_left/1/room_speed
//time_left = time_decrement * room_speed;//room_speed * 30
time_penalty = 0
time_max = time_left
time_left_past_size = round(75 / RMSPD_DELTA)//60;
    //NB: Affects the inertia in recovering from a lull in action: higher makes it harder
//moving average array
for (var i = time_left_past_size; i&gt;= 0; i--){
    time_left_past[i] = time_max;
}
time_left_ma = time_max;
time_string = string_format(max(0.00,time_left/time_decrement/room_speed),2,2);
//levelTime = room_speed * 20 * time_decrement 
//lastLevelTime = 0


//MOVES
MOVES_REMAINING = 10
moves_clear_messages = MOVES_REMAINING;
moves_time_max = scr_get_moves_maxtime(RIGOR);
moves_time_left = moves_time_max;
moves_time_active = false;
moves_time_string = string_format(max(0.00,moves_time_left/room_speed),2,2);
//c_moves_time = COLORS[0]//
//c_moves_time = COLORS[6]// 
moves_board_start = instance_number(obj_reflector_parent);
moves_board_end = moves_board_start;
//Create board modifer controller
ScheduleScript(id,false,1,CreateInstanceIfNone,x,y,obj_control_modifiers);


// Set Bar Color
mode_bar_color = COLORS[0];



//SANDBOX
sandbox_gameover[0] = false;


//STARCASH
starCashStart = STAR_CASH;
starCashEarned = 0
starCashCaught = 0
starCashNext = 250.0 
cashTimer = 0;

//SCORE NUMBERS/COUNTERS
score = 0
score_p1 = 0
score_display = 0

//Multiplayer Scores, though we use p1 for single player
if score = 0{score_p1 = 0;score_p2 = 0;score_p3 = 0;score_p4 = 0;}


//SCORE DISPLAY COORDINATES, INITIALIZED
x_score = 0
y_score = 0
x_gui = 0
y_gui = 0
mode_bar_x = 0
mode_bar_y =  0
y_adj_score = 0
x_gui_adj1 = 0
barheight = 0;
halfbarwidth = 0;

//Initialize GUI Jiggle Variables
//0 = Score Jiggle
//1 = Lives/Moves/Penalties Jiggle
//2 = StarCash
gui_jiggletime = 1.0*room_speed
for (var i=0;i&lt;8;i++){
    for (var j=0;j&lt;3;j++){
        gui_jiggle[i,j] = 0;
    }
}

//Tween in for scoreboard GUI
guiEase= EaseOutBack;//choose(EaseLinear,EaseInOutBack,EaseInOutQuad)
guiEaseReverse = EaseInBack;
scoreTween[0] = 0;
TweenScore =  TweenFire(id,scoreTween,guiEase,
                    TWEEN_MODE_ONCE,1,0,1, 0,1)
introTextEase[0] = 0;
introTextTween = noone;
                    
                    
                    
//CoolDown for BoardPowerups
globalvar 
boardWideEffectTimer, 
boardWideEffectTimerMax, 
boardFilledTimer, 
boardClearedTimer;
// Init Timers for Board Wide Effects
scr_board_wide_effects_clear();


spr_temp = -1


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Paddle Init
globalvar mouseangle, NewMAFromCenter, paddle_id, RAIL_ANGLES;
globalvar pradius, pradiusx, pradiusy, PADDLE_H; //paddle is a global var referring to obj_launcher
globalvar vertx, verty, tvertx, tverty, innerVertx, innerVerty, vertangles;
globalvar padcenterx, padcentery,pad_radius, touchPad, fieldEndY;
globalvar 
PADDLE_W, 
PADDLE_SCALE, 
PADDLE_SCALE_START,
RAIL_LENGTH, 
PADDLE_MOTION,
railCoverage,
railOverload;


 // Joystick Stuff
joystickExists = joystick_exists(1); 


//Paddle Stuff
PADDLE_MOTION = false//true;
mouseangle = 90;
NewMAFromCenter = mouseangle;
CurrentMAFromCenter = NewMAFromCenter
prevAImouseangle = NewMAFromCenter;
//paddle = 0



pradius = scr_field_calc_radius(gridSize, cellSize, railset, corner);
pradiusx = pradius
pradiusy = pradius
innerPradius = scr_field_calc_radius(gridSize, cellSize, 0, corner);

RAIL_ANGLES = scr_field_calc_angles(gridSize, corner);
startangle = RAIL_ANGLES[0]/2////22.5
RAIL_LENGTH = scr_field_calc_rail_len(pradius, RAIL_ANGLES)


//PADDLE_W = ((2)*gridSize+80)*2//1.5//*.75
//PADDLE_W = ((10)*gridSize)
var pad_w;
var padRigScale = scr_rigor_paddle_adjustment(); //+0;//+30;// + 10;//-10, -20, -40, -80
/*
//var padRigAdj = 0;
pad_w[0] = (180+padRigAdj) *padRigScale//-20//+20;
pad_w[1] = (225+padRigAdj) *padRigScale//-20//+20;
pad_w[2] = (250+padRigAdj) *padRigScale//-20//+20;
pad_w[3] = (250+padRigAdj) *padRigScale//-20//+20; // if we make this bigger then padsize must be smaller
*/
pad_w[0] = (.10 * RAIL_LENGTH) *padRigScale//-20//+20;
pad_w[1] = (.13 * RAIL_LENGTH) *padRigScale//-20//+20;
pad_w[2] = (.14 * RAIL_LENGTH) *padRigScale//-20//+20;
pad_w[3] = (.14 * RAIL_LENGTH) *padRigScale//-20//+20; // if we make this bigger then padsize must be smaller
//Alex we've tried paddle size every which way, it's better if it's easier for people.
//And 200+ minimum paddle size is necessary for that.
PADDLE_W = pad_w[GRID];
PADDLE_H = scr_paddle_calc_height(cellSize) 
//PADDLE_SCALE = (3 * TOUCH_ENABLED + 2.5 * !TOUCH_ENABLED)//3//2.75;
//PADDLE_SCALE = 3.5;//2.75;
var padCoverage = .42 - RIGOR * .04;
var careerMinutes = careerPlaytimeTotal/(60*60); // gamesPlayedTotal &gt; 2
//if gamesPlayedTotal &lt; 5 //or true
if careerMinutes &lt; 5
{ 
    padCoverage += .10 * (1 - careerMinutes/5);
    //NB: We make it a lot easier for new players.
}
//padCoverage = .65;
PADDLE_SCALE = padCoverage * RAIL_LENGTH / PADDLE_W;//2.75;
            //NB: We could also increase the pace speed is added on !touch builds...
PADDLE_SCALE_START = PADDLE_SCALE

//PADDLE_MOTION = 1;

railCoverage = 0;
railOverload = false;


//we're just taking 4*2 times the sin of each halfangle scaled by pradius which we also know ckever

fieldEndY = (centerfieldy + dsin((startangle+RAIL_ANGLES[1]))*(pradiusy+PADDLE_H+5))//+62))
fieldEndYP = (centerfieldy + dsin((startangle+RAIL_ANGLES[1]))*(pradiusy+PADDLE_H/2))//+62))

//NB: We still use touchpad center for tutorial coordinates and stuff.
padcenterx = centerfieldx
padcentery = (GAME_Y+GAME_H - fieldEndY)/2 + fieldEndY +75/2 +20 +5//why 75/2? Because i use 75 as the height of the cooldown icons
pad_radius = min(.28125*GAME_W /*180*/,((GAME_Y + GAME_H)-padcentery-5)) //* display_get_dpi_x() /326;

//show_message(string(display_get_dpi_x())+' '+string(pad_radius/96))
//show_message(string(pad_radius))


startangle = RAIL_ANGLES[0]/2////22.5
angle = startangle
for (i=0;i&lt;8;i++){
    vertangles[i] = angle
    
    innerVertx[i] = innerPradius*dcos((angle));
    innerVerty[i] = innerPradius*dsin((angle));
    
    vertx[i] = pradiusx*dcos((angle));
    verty[i] = pradiusy*dsin((angle));
    
    tvertx[i] = (pradiusx+PADDLE_H/2)*dcos((angle)); //for use in paddle calculations
    tverty[i] = (pradiusy+PADDLE_H/2)*dsin((angle)); //for use in paddle calculations
    
    
    angle+=RAIL_ANGLES[(i+1) mod 2];
}

nearestStar = 0;

paddle_id = noone // instance_create(x,y,obj_launcher)
//PADDLE_MOTION = false;

//Paddle Speed Tracking variables
PS_DSeconds = 0;
PS_Seconds = 0;
for (var i=4;i&gt;=0;i--){PS_Speeds[i] = 0;} //we'll use 5 seconds
PS_AvgPerSecond = 0;

padSpeed = .5;
padSpeedDefault = padSpeed;
padSpeedPowerSlow = .90
padOverheatTextCD[0] = true;
padOverheatTextCD[1] = -1;

for (var i=round(20/RMSPD_DELTA -1);i&gt;=0;i--){PS_MinAngle[i] = 0;} //we'll use deciseconds
thresholdAddToAngle = 0;
PS_AvgPerDeciSecond = 0;

tutorialPaddleMovePercent = -1;






objPControl= instance_create(0,0,obj_control_powerups)
objDebug = instance_create(0,0,obj_control_debugger)
objRail = instance_create(centerfieldx,centerfieldx,obj_control_rail_lines) 
    //NB: instance_created last for texture batch reasons, because it generates a sprite
   

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Star Init (Speed)
var sSpeeds;
sSpeeds[0] = 4.90;
sSpeeds[1] = 4.65;
sSpeeds[2] = 4.40;
sSpeeds[3] = 4.15;

globalvar 
starSpeedRaw, 
starSpeedReal, 
starSpeedBase,
starSpeedNoDelta, 
speedModPower;

starSpeedRaw = sSpeeds[GRID] * RMSPD_DELTA;
starSpeedBase = starSpeedRaw;
starSpeedNoDelta = starSpeedRaw;
starSpeedReal = starSpeedRaw;
//Impact of Faster/Slower Powers as a Percentage of StartSpeed
speedModPower = (.085 -.01 * (GRID))



//Time Over Speed Penalties
globalvar time_over, time_over_elapsed, time_over_speed;
time_over = false
time_min = time_left;
time_over_elapsed = 0;
time_over_speed = 0//.25 //maybe let's make this grow the longer you're at 0:00




//unused
//refdir = 'basic'

//spawnSet = true;
image_speed = 0




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Controls Init




scr_tp_controls_init();

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Particles, Shake, Combos, Everyplay

/*part_emitter_region(PSYS_SUBSTAR_LAYER, PSYS_SUBSTAR_LAYER_EMITTER, ox, ox+fieldW*cellW, oy, oy+fieldH*cellH, 
                    ps_shape_ellipse, ps_distr_linear);
*/

// Enable Auto Everyplay Record
if EVERYPLAY_AUTO {
    //scr_everyplay_stop_recording();
    everyplay_start_recording();
}


// Set Particle Stuff
scr_part_systems_set_depth();                    
scr_part_types_adjust_for_game();

// Set Pause Stuff
pause_color = COLORS[0];
pause_scale = 1;



// Set Bomb Stuff
scr_bomb_force_clear();

globalvar SHAKE_POWER, SHAKE_TIME;
SHAKE_POWER = false
SHAKE_TIME = -1
restoreFPSTween = noone//TweenCreate(id,room_speed__,false,EaseLinear,room_speed,RMSPD_DEFAULT,15)


//Combo vars
global.pComboTimer = -1
global.pComboTimerMax = 2*room_speed
global.pComboCount = 0
global.pComboColor = 0;

//Make array of all viable color indexes
global.pComboColorSwitched[0] = false;
global.pComboColorSkins[0] = CURSKIN;
for (var i = 0, s = 0; i &lt; SKIN_COUNT; i++){
    //Skip current skin
    if i != CURSKIN{
        //if unlocked
        var key = scr_unlock_get_key(3,i);
        var data = UNLOCKS_DATA[? key];
        if data[1] != 0{
            global.pComboColorSkins[++s] = i;
        }
    }
}

// Clear Gameplay Screenshot from Prev Game
scr_share_screen_reset();

//Beat Stuff
var_beat_time = 500000//in microseconds
var_time_pass = 0
var_beat_list = ""//"ABCDEDFGEABCDFAGBCGFEDABCFZ" //""
var_beat_list_ex = string_delete(var_beat_list, 1, 1) + "Z";


///streak text
streak_words[0,0] = "nubious"
streak_words[0,1] = "astronomical"
streak_words[0,2] = "cosmic"
streak_words[0,3] = "phenomenal"
streak_words[0,4] = "delightful"

streak_words[1,0] = "smart"
streak_words[1,1] = "boffo"
streak_words[1,2] = "fresh"
streak_words[1,3] = "stellar"
streak_words[1,4] = "majestic"

streak_words[2,0] = "trismegistus"
streak_words[2,1] = "fantastic"
streak_words[2,2] = "tremendous"
streak_words[2,3] = "blitzkrieg"
streak_words[2,4] = "illustrious"

streak_words[3,0] = "starific"
streak_words[3,1] = "startastic"
streak_words[3,2] = "starmazing"
streak_words[3,3] = "starceptional"
streak_words[3,4] = "starmented"

streak_words[4,0] = "remarkable"
streak_words[4,1] = "marvelous"
streak_words[4,2] = "divine"
//streak_words[4,3] = "herculean"
streak_words[4,3] = "superb"
streak_words[4,4] = "celestial"

streak_words[5,0] = "stunning"
streak_words[5,1] = "sensational"
streak_words[5,2] = "outstanding"
streak_words[5,3] = "spectacular"
streak_words[5,4] = "sublime"



//Narrow Miss Words
near_miss = false;
var i = -1;
near_miss_words[++i] = "close call";
near_miss_words[++i] = "close shave";
//near_miss_words[++i] = "narrow escape";
//near_miss_words[++i] = "hairbreadth save";
//near_miss_words[++i] = "hairbreadth";

near_miss_words[++i] = "super recovery";
//near_miss_words[++i] = "recovery";
//near_miss_words[++i] = "nearly fatal";
near_miss_words[++i] = "heartstopper";
//near_miss_words[++i] = "near miss";

//near_miss_words[++i] = "dangerous";
near_miss_words[++i] = "salvation";
near_miss_words[++i] = "redemption";
near_miss_words[++i] = "heroic";

//near_miss_words[++i] = "on the rims";
//near_miss_words[++i] = "out of the fire";
near_miss_words[++i] = "miraculous";
near_miss_words[++i] = "gutsy";


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Tutorial and boardinit

globalvar TUTORIAL_STARTED;
TUTORIAL_STARTED[0] = 0;


//Run board init
scr_board_init()

//Spawn tutorial controller
if !instance_exists(obj_control_tutorial){
   ScheduleScript(id,false,1,CreateInstance,x,y,obj_control_tutorial)
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///debugging scratch pad [disable]


//show_message("App surf enabled="+string(application_surface_is_enabled()))
/*
test = 10;
scr_test_scope(true);
show_message("object scope, TEST = "+string(test));

mouse_str = ""
mouse_final_str = ""

/*
debug_array[0] = 1*PADDLE_SCALE

if is_array(debug_array) {show_message('array is array')}
else {show_message('array is not array')}

var i;
for (i = 0; i &lt; instance_number(obj_Enemy); i += 1)
   {
   enemy[i] = instance_find(obj_Enemy,i);
   }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///changing field saturation %

var adj_field;
if railOverload{ //we reduce DENSITY during overload 
    adj_field = -.05
}
else if global.ActiveStarCount == 1{ //we increase DENSITY during low action times
    adj_field = .05
}
else adj_field = 0;

if level &gt; ceil(10/levelDiffAdj) {fieldSat = random_range(.85,1.15) ;}
else fieldSat = random_range(1.00,1.10 ) ; //random_range(.95,1.05);

fieldSat += adj_field;


fieldSet = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Ready Up

if GAME_ACTIVE{

    MOVE_READY = true;
    
    //PADDLE_MOTION = true;
    if MODE != MODES.MOVES and MODE != MODES.SANDBOX{
         if !instance_exists(paddle_id){
            paddle_id = instance_create(0,0,obj_launcher)
            //Tween in Touchpad
            if !TUTORIAL_ENABLED and !TUTORIAL_STARTED[0]{
               scr_touch_pad_tween_in(); 
               //could also delay this to follow the obj_launcher tween
            }
         }
    }
    else{
        with (obj_control_modifiers){
            if !TUTORIAL_ENABLED and !TUTORIAL_STARTED[0] and !TweenExists(MixersTween){
               MixersTween = TweenFire(id,MixersEase,EaseLinear,
                                TWEEN_MODE_ONCE,1,0,1, MixersEase[0],1); //guiEase
            }
            
            if MODE == MODES.SANDBOX{
               //set mixer counts to 99.
               for (var z = 0, n = array_height_2d(boardMixers); z &lt; n; z ++){
                   boardMixers[z,0] = 99;
               //Might be dangerous to have so many stars, we'll see.
               //again we'll need some error code for a filled board.
               }
               //Set Stars to 5;
               boardMixers[0,0] = 10;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Main Game Loop



if GAME_ACTIVE  and !TUTORIAL_ENABLED {
    
    // Calculate Star Count
    global.ActiveStarCount = instance_number(obj_star);

    // Set Shooter Speed
    if global.ActiveStarCount &gt; 0 {
        //Freeze Stars During Pause (And While Taking Screenshots)
        if GAME_PAUSE {
            starSpeedReal = 0; 
        }
        else {
            // Calculate Correct Speed Every X Interval
            if true {//QUARTER_SECOND_INTERVAL {
                var speedModCount, speedModExponent, speedMin, speedMax, newSpeed;
                // Calculate Speed Powers
                speedModCount = (POWER_faster[@ 0]  - POWER_slower[@ 0]);
                speedModExponent = abs(speedModCount);
                speedModBase = 1 + speedModPower * sign(speedModCount);
                newSpeed = starSpeedRaw * power(speedModBase,speedModExponent)
                // Calculate Speed Tappers
                speedMin = starSpeedBase *.25;
                speedMax = starSpeedBase * 25
                speedTappersMultiplier = POWER_addslower[@ 7]*POWER_subfaster[@ 7];
                newSpeed = clamp(newSpeed * speedTappersMultiplier,speedMin,speedMax);
                // Calculate Speed Penalties
                speedPenaltyMultiplier = 1 + time_over_speed * time_over;
                newSpeed *= speedPenaltyMultiplier;
                // Cache No Delta Speed
                starSpeedNoDelta = newSpeed;
                // Adjust for Delta Time
                newSpeed *= (DELTA_TIME_SCALAR)//old_delta_time ); 
                //Ease to New Shooter Speed
                starSpeedReal += (abs(newSpeed) - starSpeedReal) * .1;
                
            }  
        }
    
    }



    //If no stars remaining
    if (global.ActiveStarCount == 0 and MOVE_ACTIVE){
    
        //Reset Round State
        scr_reset_round_state()
        //Increment Round Count
        MOVE_COUNT += 1;
        

        //If Arcade mode subtract life
        if MODE == MODES.ARCADE {lives -= 1;}
        //If Moves mode subtract a move
        if MODE == MODES.MOVES{
           //if !instance_exists(obj_launcher){paddle_id = instance_create(x,y,obj_launcher)}
           MOVES_REMAINING -= 1 //maybe rename this MOVES_REMAINING
           boardMixers[bMStarIndex,0] += 1;
           // Reset Move Time
           scr_mode_moves_reset_time();
          
           //moves_time_active = false;
           // Get End Clear Value
           moves_board_end = instance_number(obj_reflector_parent);
           
           /*
           if moves_board_end &gt; moves_board_start {
            show_message("BUGG MOVES COUNT");
                /// NB: This can happen if you add objects to the board.
           }*/
           
        }
        //If Time mode add pentalty
        if MODE == MODES.TIME and time_left &gt; 0{//if false won't fire
           time_penalty +=1 //increase level difficulty by +10% without adding points multiplier
           //Jiggle Penalty Icon
           gui_jiggle[2,0] = gui_jiggletime;
           
           
           //Dock Time for Penalty
           var time_subtracted = max(time_left * .5, time_max * 5/30) 
                                //half time or 5 seconds, whichever's bigger
           time_left = max(time_left - time_subtracted, min(time_left, time_max * .001 / 30))  //NB: Min 0:00 time
                                // keep above time_left or .1 seconds, whichever's bigger
           //Update Time String
           time_string = string_format(max(0.00,(time_left/time_max)*30),2,2);///time_decrement
           
           //Dialogue text on use
           txt_font = fnt_game_bn_40_bold;//; 
           txt_text = "+1 penalty";
           draw_set_font(txt_font)
           txt_height = string_height("H")*.6 + string_height(txt_text)/2;
           scr_popup_text_field_static(centerfieldx,centerfieldy+txt_height,
                txt_text,COLORS[2],txt_font)
        
           
        }
        
        //Respawn board, retween and reset vars
        if lives &gt; 0 and MOVES_REMAINING &gt; 0 and time_left &gt; 0 {
            scr_respawn_tween()
        }
        //Lets see if there's a more elegant way for this
        scr_sound(sd_turn_end,1)// audio_play_sound(sd_turn, 1, false);
        
        //Set per death stats
        lastDeaths += 1
        if lastPPD &gt; highestPPD {highestPPD = lastPPD}
        if lastRPD &gt; highestRPD {highestRPD = lastRPD}
        if lives &gt; 0 {
           lastPPD = 0
           lastRPD = 0
        }
        
        //If Sandbox mode 
        if MODE == MODES.SANDBOX{
           //Outro Paddle
           with (paddle_id){
               ScheduleScript(paddle_id, false, 2, scr_paddle_tween_out);
           }
           scr_touch_pad_tween_out(); 

           //reset mixer counts to 99.
           for (var z = 0, n = array_height_2d(boardMixers); z &lt; n; z ++){
               boardMixers[z,0] = 99;
           }
           //Set Stars to 5;
           boardMixers[bMStarIndex,0] = 10;
           
           
        }
    }
   
    // LEVELUP STUFF
    if score &gt; levelScore and levelUp = false{
    
        //Level Up Update Stats
        level++
        lastLevelScore = levelScore
        //Cap for Pace of Level Increment
        levelCap = ceil(24/levelDiffAdj) 
        levelScore += levelScoreStart * (1+(/*.25*/.15*(min(level,levelCap))))//*(1 + 1*(level &gt; 5)) //level up first five faster
        //levelScore += 100.0 * (1+(.25*(level-1)))
         
        
        // Level Up Text Dialogue
        txt_font = fnt_game_bn_40_bold;//; 
        txt_text = "level up x"+string(level);
        //draw_set_font(txt_font)
        //txt_height = string_height(txt_text)*1.1;
        scr_popup_text_field_static(centerfieldx,centerfieldy,
        txt_text, COLORS[0],txt_font);
        scr_sound(sd_difficulty_increases,1,false)
        // Level Up Screenshake
        scr_shake_add(.5 * room_speed, 4);
        
        // Level Up Increase Speed and Shrink Paddle
        //NB: Everything is scaled by difficulty and grid size to even pace and points
        var levelMin, speed_inc, speed_new, speed_top_rate, speed_exp, speed_level_cap,
            paddleSize_exp, paddleSize_dec, paddleSize_new;
        levelCap = 24 / levelDiffAdj;
        levelMin = level-1//min(levelCap,(level-1));//*levelDiffAdj;
            //NB: I'm going to try it getting infitely harder and see how it feels.
        
        // Speed Up Stars
        //speed_level_cap = 20 / levelDiffAdj;
        speed_level_cap = levelCap//30 / levelDiffAdj; // how many levels to get to top speed?
        speed_top_rate = 1.05 + RIGOR * .025// what is the top speed as proportion of start speed?  
        //speed_top_rate = 1.075 + RIGOR * .025// what is the top speed as proportion of start speed?  
            //NB: My analytics suggest it's too hard right now, so I'm going to lower the difficulty a bit.
        //NB: This Speed is only asymptotically approached, never reached
        speed_exp = 1 //Used For Linear Approach to Top Speed //CurrentExponent 
        speed_inc = starSpeedBase * (speed_top_rate-1) / speed_level_cap //get speed increment size
        speed_new = starSpeedBase + speed_inc * power(levelMin*(1+ .20*time_penalty), speed_exp)
                                                        //NB: We've raised time penalty from .10 to .20.  I think a good decision.
        // Update Star Speed
        starSpeedRaw = speed_new;
        
        // Shrink Paddle
        //Asymptotic Shrink
        paddleSize_dec = (PADDLE_SCALE_START / (levelCap)); // Asymptotic Shrink
        paddleSize_exp = .70;// + RIGOR*.025; //Used For Asymptotic Approach  to Shrinking
        //paddleSize_exp = .75; //Used For Asymptotic Approach  to Shrinking
        paddleSize_new = max(1, PADDLE_SCALE_START - paddleSize_dec * power((level-1) * (1 + .20*time_penalty), paddleSize_exp));//.80));
                                                        //NB: We've raised time penalty from .10 to .20.  I think a good decision.
            //NB: If it's too hard we can lower the exponent even more.
            //NB: But I much prefer this Asymptotic system over the linear one, it's just too easy with the linear one.  
        //Linear Shrink
        //paddleSize_dec = (PADDLE_SCALE_START -1) / ( levelCap ); //Linear Shrink
        //paddleSize_exp = 1 //+ RIGOR*.05; //Used For Linear Approach to Shrinking
        //paddleSize_new = max(1, PADDLE_SCALE_START - paddleSize_dec * power(levelMin * (1 + .20*time_penalty), paddleSize_exp));//.80));
        // Update Paddle
        if (PADDLE_SCALE &gt; paddleSize_new) {
            PADDLE_SCALE = paddleSize_new
            scr_scale_paddle();
            //Color paddle briefly on level up
            with(paddle_id){
                 padColorTimers[1] = max(
                 padColorTimers[1],room_speed*.25)
            }
        }
    }
    
    //TIME KEEPER VARS
    if MOVE_ACTIVE{
        roundPlaytime += 1
        lastPlaytime += 1
        
        //Time Mode decrement
        if MODE == MODES.TIME{
            //NB:  Time only increases from paddle related actions e.g. catching and rebounding.
            //This makes it much cleaner to balance.
            
            //Use Time_Max to represent full bar 30:00
            time_max = max(time_max,time_left);
            //Set Moving Average each .5 seconds
            if HALF_SECOND_INTERVAL{
                //Add current time remaining to moving average array
                time_left_past[0] = time_left;
                var time_max_weight = .35//.3//.25;//.5 //timemax weighting
                    //NB: Describes how diffcult a spike in points can make the rest of the game.
                            //NB: This is offset by the level multiplier partially.
                //Sum by weight
                time_left_ma = array_avg_1d(time_left_past) * (1-time_max_weight) + time_max_weight*time_max;
                //Move back index of each time value
                for(var i=1; i &lt; time_left_past_size; i++){
                    time_left_past[i] = time_left_past[i-1];
                }
                
            }
            //Decrement remaining time each STEP 
            time_left -= time_decrement
            time_over = false
            //Is Time Over?
            if time_left &lt;= 0{
                
                //Flag overtime
                time_over = true;
                // Get lowest time
                time_min = min(time_min, time_left)
                //We use this var to progressively increase the out of time speed penalty
                time_over_speed = min( abs(time_min) / time_max + .25, 3); //performance based, scales star speed.
                                    //NB: This is added to 1.  So it's a min of 1.25 and max of 3.
 
            }
            
            //keep summing decrements (currently unused)
            time_elapsed += time_decrement
            
            //Set time decrement based on moving average
            //time_decrement = time_max_avg /(room_speed*30) //time_max
            time_decrement = time_left_ma /(room_speed*15) //time_max
                //NB: Describes how fast you can go from full to empty.  Smaller denominator means it can happen fast (which makes things hard).
            
            //Set time string
            //time_string = string_format(max(0.00,(time_left/time_max)*30),2,2);///time_decrement
            //time_string = string_format(max(-5.00,(time_left/time_max)*30),2,2);///time_decrement
            time_string = string_format((time_left/time_max)*30,2,2);///time_decrement
            // If Plenty of Time
            if real(time_string) &gt; 7.5{ 
                mode_bar_color = COLORS[0]
            }
            // If Running Out Of Time
            else if real(time_string) &gt; 0 {
                    mode_bar_color = merge_color(COLORS[2], COLORS[0],lerp(0,1,FULL_SECOND_LERP));
            }
            // If Out Of Time
            else {
                mode_bar_color = COLORS[2] ;
            }
        }
    }
    else if !MOVE_ACTIVE and MOVE_READY and moves_time_active{
       roundPlaytime += 1 //in Moves mode the between activity time counts as playtime, because it is.
       lastPlaytime += 1
       
       //Move Time decrement
       if MODE == MODES.MOVES{
          
       
          //Decrement remaining time each STEP 
          moves_time_left -= 1;
          
          
          //Set time string
          moves_time_string = string_format(max(0.00,moves_time_left/room_speed),2,2);
          var moves_time_threshold = max(10,.33 * moves_time_max) //10.00 
          if moves_time_left &gt; moves_time_threshold {
               mode_bar_color = COLORS[0]
          }
          else if moves_time_left &gt; 0{
               mode_bar_color = merge_color(COLORS[2], COLORS[0],lerp(0,1,FULL_SECOND_LERP))
               //Clock Tick Tock
               scr_clock_tick_tock();
          }
          else {
            mode_bar_color = COLORS[2];
          
          }
          
          //Time is Up, Activate Move Anyway
          if moves_time_left &lt;= -.5 * room_speed{ //we give them an extra .5 seconds past 0.00
             
             //if !instance_exists(obj_star_marker){
             //}
             with (obj_star_marker){
                star_launch = true;
             }
             MOVE_ACTIVE = true;
          }
          
       }
    }
}



if MOVE_ACTIVE {

    // Populate Board
    if roundPlaytime &gt; spawnDelay{//and MODE != 2{
    
        //If Not Moves Mode
        if MODE != MODES.MOVES{
            // Set Respawn Timers
            scr_field_respawn_queue()
        } 
        
        // Update Respawn Timers and Execute them
        scr_field_respawn_update()
        
       
    }

    // Update and Detonate Bomb Timers
    scr_bomb_queue_update();
    
        
    //Ease Explosion Parameters Based on Counts
    if scr_particle_explosion_number() &gt; BOARD_TOTAL * .4{ //.25
        //If too many particles ease towards .5 duration
        P_Destroy_Vals[0] += (.5 - P_Destroy_Vals[0]) * .1 * RMSPD_DELTA; 
        scr_particles_explosion_set();
    }
    //Else Return Particles to 1: origin val
    else if P_Destroy_Vals[0] != 1 { 
        P_Destroy_Vals[0] += (1 - P_Destroy_Vals[0]) * .1 * RMSPD_DELTA;
        scr_particles_explosion_set();
    }
    /* NB: I like this effect and the impact on performance is neglibible
    
    */
    
    // Take Gameplay Screenshot for Sharing
    scr_share_screen_gameplay_make();  //EVALUATE ME
    /*  NB: I found this lagged too much on mobile :(, mostly android...
        We should try it on iOS though
    
    */
    
    
    
}

/*
//Trigger Delayed Destruction
var key, value;
if MOVE_ACTIVE{
    for (var gx = 0; gx &lt; fieldW ; gx++){
        for (var gy = 0; gy &lt; fieldH ; gy++){
        
            key = string(gx)+","+string(gy);
            value = global.DEATHTIMERS[#? key]
            if is_undefined(value) continue;
            
            //Pull and decrement value
            value -= 1;
            global.DEATHTIMERS[#? key] = value;
            
            
            if abs(value) &lt; .5 {
               
               scr_bomb_delayed(gx,gy)
               ds_map_delete(global.DEATHTIMERS, key);
            }
            //Error Catching block
            else if value &lt; -1*room_speed{
               ds_map_delete(global.DEATHTIMERS, key);
            }
        }
    }
}*/
/*
var size, key, next, value;
size = ds_map_size(global.DEATHTIMERS)
key = ds_map_find_first(global.DEATHTIMERS)
for (var i = 0; i &lt; size ; i++){

    //Set next key so we can delete stuff.
    next = ds_map_find_next(global.DEATHTIMERS, key);

    //Pull and decrement value
    value = global.DEATHTIMERS[#? key] - 1;
    global.DEATHTIMERS[#? key] = value;
    
    
    if abs(value) &lt; .5 {
    
       //Parse coordinates from key
       var SepPos = string_pos(",",key); //starts at 1, 0 is invalid.  strange.
       var XCoord = real(string_copy(key, 1, SepPos-1));
       var YCoord = real(string_copy(key, SepPos+1, string_length(key)));
       
       scr_bomb_delayed(XCoord,YCoord)
       
       ds_map_delete(global.DEATHTIMERS, key);
    }
    //Error Catching block
    else if value &lt; -1*room_speed{
       ds_map_delete(global.DEATHTIMERS, key);
    }
    
    //Iterate to next key.
    key = next; 
}*/


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Controls Detection

// Detect The Touch for TouchPad    
scr_set_touch_pad_touch();

// Prevent TP from moving when button is touched
scr_touch_pad_reset_button();

//Detect If Sensitivity Changed
scr_tp_reset_rad()




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Paddle Movement

//mouse angle
if instance_exists(obj_launcher) and !GAME_PAUSE and GAME_ACTIVE 
{

    if PADDLE_MOTION
    {
        //PC MOUSE BASED CONTROLS
        if !TOUCH_ENABLED
        {
            // Desktop
            if CONFIG != CONFIG_TYPE.HTML {
                //New Mouseangle
                NewMAFromCenter = darctan2(mouse_y-centerfieldy,mouse_x-centerfieldx);
            }
            // HTML5
            else {
                //New Mouseangle
                scr_HTML5_mouse_set_xy();
                NewMAFromCenter = darctan2(html_my-centerfieldy,html_mx-centerfieldx);
                
            }
            
            
            /* NB: This is all the keyboard WASD Controls:
            // If Mouse Was Moved, Use Mouse To Decide Location
            if mouse_x != oldVMX + (view_xview[0] - VIEW_X) or mouse_y != oldVMY + (view_yview[0] - VIEW_Y) {
                //New Mouseangle
                NewMAFromCenter = darctan2(mouse_y-centerfieldy,mouse_x-centerfieldx);
                //NewMAFromCenter = darctan2(device_mouse_raw_y(0)-centerfieldy,device_mouse_raw_x(0)-centerfieldx);
                
                // Override Virtual Mouse Coords
                VMouseX = mouse_x;
                VMouseY = mouse_y;
                VMState = 0;
            }
            // Else Use WASD
            else {
            
                //Set WASD Mouse Location
                scr_vmouse_set()
            
                //Use Virtual Mouse Coords
                NewMAFromCenter = darctan2(VMouseY-centerfieldy,VMouseX-centerfieldx);
            
            } 
            oldVMX = mouse_x - (view_xview[0] - VIEW_X); ///subtract shake values
            oldVMY = mouse_y - (view_yview[0] - VIEW_Y);
            */
            
            //FAUX TOUCHPAD MOVEMENT
            if touchPad == 3{
                tp_dummy = true;
                
                oldMX = dynamicCenterX + (mouse_x-centerfieldx) /pradiusx *tp_dist_max
                oldMY = dynamicCenterY + (mouse_y-centerfieldy) /pradiusy *tp_dist_max
                
                //NB: For Keyboard WASD Controls
                //oldMX = dynamicCenterX + (VMouseX-centerfieldx) / pradius *tp_dist_max
                //oldMY = dynamicCenterY + (VMouseY-centerfieldy) / pradius *tp_dist_max            
            }
            
            
          
            //JOYSTICK BASED CONTROLS
            if joystickExists{
               jy = joystick_ypos(1);
               jx = joystick_xpos(1);
               if point_distance(jx, jy, 0, 0) &gt; .3{
                  NewMAFromCenter = darctan2(jy,jx)
               }
            }
            
            
        }
        //MOBILE TOUCHPAD BASED CONTROLS
        else if TOUCH_ENABLED and SWIPE and SWIPE_BRK
        {
            //How fast dynamic center eases to new location
            //centerSpd = .15 * RMSPD_DELTA//1//.2// //EVALUATE ME
            centerSpd = .30 * RMSPD_DELTA//1//.2// //EVALUATE ME
            
            //Get New Mouseangle
            NewMAFromCenter = darctan2(mouse_y-dynamicCenterY,mouse_x-dynamicCenterX);
            
            
            //Distance from center to mouse
            DCtoMouseDist = point_distance(mouse_x,mouse_y,dynamicCenterX,dynamicCenterY)//sqrt(sqr(dynamicCenterX-mouse_x) + sqr(dynamicCenterY - mouse_y))
            
            //Radius from center, floored at TR_min
            centerRad = max(DCtoMouseDist, TR_min);
                
            // If Fluid Controls
            if TP_SENSE[1] == 0 {
                // If DC is Dragged Far Enough
                if centerRad &gt; TR_max and !TUTORIAL_ENABLED {
                    // Ceil Radius
                    centerRad = TR_max
                    
                    //Calculate distance to New DynamicCenter
                    newDCXrad = dcos((NewMAFromCenter))*centerRad //* TouchRad;
                    newDCYrad = dsin((NewMAFromCenter))*centerRad //* TouchRad;
                    
                    // ReCache Fluid DynamicCenter
                    TOUCH_FLUID_X = (mouse_x - newDCXrad)
                    TOUCH_FLUID_Y = (mouse_y - newDCYrad)
                }
                
                //Difference between old dynamic center and new dynamic center, for easing later
                DCXdelta = TOUCH_FLUID_X - dynamicCenterX;
                DCYdelta = TOUCH_FLUID_Y - dynamicCenterY;
            } 
            // If Fixed Control
            else if TP_SENSE[1] == 1 {
            
                // Set Delta needed to Ease Back to Fixed Center
                DCXdelta = TOUCH_FIXED_X - dynamicCenterX;
                DCYdelta = TOUCH_FIXED_Y - dynamicCenterY;
            
            } 
            // Linear Controls
            else if TP_SENSE[1] == 2{
            
                // Set Delta needed to Ease Back to Fixed Center
                DCXdelta = TOUCH_FIXED_X - dynamicCenterX;
                DCYdelta = TOUCH_FIXED_Y - dynamicCenterY;
                
                
                // Get Angle Delta 
                TL_old = darctan2(oldMY-dynamicCenterY,oldMX-dynamicCenterX);;
                TL_new = darctan2(mouse_y-dynamicCenterY,mouse_x-dynamicCenterX);
                TL_diff = angle_difference(TL_new,TL_old);
                
                // Calculate Sensitivity
                TL_sense = .75 + .75 * TP_SENSE[0];//scalar ranging from .75 to 1.5
                
                //Calculate Angle Delta
                TL_delta = ( TL_diff * 5 * TL_sense );  //sensitivity could go here
                
                // Set New Angle
                TOUCH_LINE_START_ANGLE += TL_delta;
                NewMAFromCenter = TOUCH_LINE_START_ANGLE;// + TL_delta;
                
            
            }
                
             // Calculate Angle Delta Needed To Ease DynamicCenter Back
            NewFixedMAFromCenter = darctan2(mouse_y-dynamicCenterY+DCYdelta,mouse_x-dynamicCenterX+DCXdelta)
            FixedDiff = angle_difference(NewFixedMAFromCenter,NewMAFromCenter);
            
            // Set Max Angle Change We Would Tolerate
            FixedDiffMax = 1//2.5;
            // If Max Exceeded, Don't Move
            if abs(FixedDiff) &gt; FixedDiffMax {
                DCXdelta = 0;
                DCYdelta = 0;
            }
            
            //Calculate angle mouse has moved since last STEP
            if mouse_y != oldMY or mouse_x != oldMX { 
                //NB: We keep the previous MAFromMove if no movement.
                //I think since mx/my are reals it's hardly ever an issue...
                MAFromMove = darctan2(mouse_y-oldMY,mouse_x-oldMX)
            }
            
            // If Mouse Too Close to Center
            if  DCtoMouseDist &lt; centerRad {
            
                // Get Mouse Velocity
                var MouseVelocity = point_distance(oldMX,oldMY,mouse_x,mouse_y);
                // Get Detection Threshold
                var MouseVelThreshold = 5 * global.dpiX * RMSPD_DELTA;
                // If Velocity is above Threshold, Don't Move Dynamic Center at All
                if MouseVelocity &gt; MouseVelThreshold
                {
                    // Clear The DynamicCenter Movement
                    DCXdelta = 0
                    DCYdelta = 0
                }
                // Else If Moving, Displace the Angle
                else //if MouseVelocity &gt; 0
                {
                    // Get NewMAFromCenter from the perspect of the mouse
                    var MAtoCenter = NewMAFromCenter-180;
                    // Normalize by subtracting MouseMovementAngle and Extract Sign
                    var MAsign = sign(angle_difference(MAtoCenter - MAFromMove, 0));
                    
                    // Get Angle That DC Will Move Away from Mouse
                    var NewDCangle = MAFromMove + 90 * MAsign;
                    //Calculate the magnitude
                    var DCmagnitude = point_distance(0,0,DCXdelta,DCYdelta);
                        //NB: We found it superior to just use DCmagnitude instead of dcos which gave us wrong numbers and made controls bad
   
                    // Get New Delta Coordinates To Ease DC
                    DCXdelta = dcos(NewDCangle)*DCmagnitude;  
                    DCYdelta = dsin(NewDCangle)*DCmagnitude;
                    
                
                }
                
            }
            //Ease DC towards appropriate distance away from mouse
            if !TUTORIAL_ENABLED {
                dynamicCenterX += DCXdelta * centerSpd 
                dynamicCenterY += DCYdelta * centerSpd
            }
            
                //NB: this is probably where we would do some checking on the range of touch radius .8-1.2?
            
                
            //Keep track of Previous MX/MY
            oldMX = mouse_x;
            oldMY = mouse_y;
              
           
        }  
            
        // Normalize to prevevent overheat
        while (NewMAFromCenter &lt; 0) {
            NewMAFromCenter += 360;
        }
        while (NewMAFromCenter &gt; 360) {
            NewMAFromCenter -= 360;
        } 
         
        //AUTOAIMER
        if MOVE_ACTIVE and 0 //false
        {
            //We can use a different touchPad flag for this
            scr_paddle_autoaimer(180)//5)//
        }
        
        // Set New Mouse Angle From Center
        CurrentMAFromCenter = NewMAFromCenter;
        
        //Update Offset Mouseangle for Offset Downer 
        if POWER_offsetpaddle[@ 7] != 0{
            CurrentMAFromCenter += POWER_offsetpaddle[7];
        }
    }
    
    
    //CALCULATE addToAngle VARS
    var maxaddToAngle, addToAngle, currentAngle, angleSign, slowPenalty;
    
    //Invert Paddle Controls Downer
    if POWER_invertcontrols[@ 0]{
       //Set Inverted Mouse Angle
       if POWER_invertcontrols[@ 7] == -1 POWER_invertcontrols[@ 7] = mouseangle;
       
       //Use Inverted Mouse Angle
       currentAngle = POWER_invertcontrols[@ 7]
       angleSign = -1;
    }
    else{
       //Use Normal Mouse Angle
       currentAngle = mouseangle
       angleSign = 1;
    }
    
    

    
    
    // Set Maximum Angle to Add
    maxaddToAngle = angle_difference(CurrentMAFromCenter,currentAngle)*angleSign;//.5
    //Slow Paddle Controls Powerdown
    slowPenalty = 1-padSpeedPowerSlow*(POWER_slowpaddle[@ 0] &gt; 0); //.5
    // Set Angle to Add
    addToAngle = maxaddToAngle * max(0,padSpeed) * slowPenalty;
    //NB: Might also put a clamp on angle difference when power_slow is on, so as to keep you from being able to move fast at all
    
    
    
    //MAKE PADDLE STICKIER FOR PRECISION
    if !MOVE_ACTIVE and //Not Active Gameplay
       TOUCH_ENABLED and //Touch Controls
       !TUTORIAL_ENABLED //No Tutorial
       //and os_type != os_windows //Not In Windows (For Testing)
    { 
        //NB: If paddle is moving slow, activate precision aiming to counter fat-fingering
        
        // Set Minimum Angle Movement (to Unstick)
        var thresholdVelocity = PS_AvgPerDeciSecond / 5; 
        
        
        // If Paddle Velocity Greater than Minval or 
        if array_avg_1d(array_slice_1d(PS_MinAngle,0,round(5/RMSPD_DELTA))) &gt;= thresholdVelocity
        {
           // Set Threshold for AddAngle to Nothing
           thresholdaddToAngle = 0;
        }
        //Else Enable Stickiness (High Threshold)
        else
        {
            thresholdaddToAngle = 5//(5 - thresholdaddToAngle) * .01 * thresholdVelocity/max(1,PS_AvgPerDeciSecond)
        }
        
        // If AddAngle is Less Than ThresholdAddAngle, 
        if abs(addToAngle) &lt; thresholdaddToAngle{
            // Clear Add Angle
            addToAngle = 0 
        }
        
        //NB: Another option might involve snapping the paddle to the x,y grid
    }
    
    
    
    
    
    //KEEP TRACK OF PADDLE ROTATION SPEED/VELOCITY OVER TIME
    PS_DSeconds += abs(addToAngle); //speed in this STEP
    if TENTH_SECOND_INTERVAL{
       //Push all other array values one index up in array
       for (var i = array_length_1d(PS_MinAngle)-1; i &gt; 0; i--){
           PS_MinAngle[i] = PS_MinAngle[i-1] //This way we only track last 5 seconds
        }
       PS_Seconds += PS_DSeconds;
       PS_MinAngle[0] = PS_DSeconds;
       PS_AvgPerDeciSecond = array_avg_1d(PS_MinAngle)
       PS_DSeconds=0;
    } //sum speed in last 10 deciseconds
    if FULL_SECOND_INTERVAL{ //log speed over a few seconds
    
       //Push all other array values one index up in array
       for (var i = array_length_1d(PS_Speeds)-1; i &gt; 0; i--){
           PS_Speeds[i] = PS_Speeds[i-1] //This way we only track last 5 seconds
        }
       PS_Speeds[0] = PS_Seconds; 
       PS_Seconds = 0;
       PS_AvgPerSecond = array_avg_1d(PS_Speeds)
    }
    
    //If Average spin of paddle crosses threshold, tween it down 
    if PS_AvgPerSecond &gt;= 400 {
        padSpeed -= (padSpeed - .05) * .025 * clamp(PS_AvgPerSecond,1,1200)/400 * RMSPD_DELTA 
    } 
    //Else if Average spin of paddle substantially below threshold, tween it back up 
    else if PS_AvgPerSecond &lt; 400 {
        padSpeed -= (padSpeed - padSpeedDefault) * .05 * 400/clamp(PS_AvgPerSecond,1,1200) * RMSPD_DELTA
    }
    //if !is_real(padSpeed) padSpeed = 0;
    //In case padSpeed == NaN...
    padSpeed = clamp(real(padSpeed),.05,.5)
    
    //If this isn't punishment enough I can nerf the extension too.
    
    //So 400-1000 looks like around a critical speed threshold
    //so let's start it at around 400, and we can see if that is enough penalty; maybe 300
    //100 average speed was about normal
    
    //i don't think a linear punishment makes sense.  because you'll get most of the benefits still
    //
    

    
    
    
    //Spawn Overheat Text
    if padSpeed &lt; .5 * padSpeedDefault 
    and padOverheatTextCD[1] &lt;= 0
    and padOverheatTextCD[0]{
        padOverheatTextCD[0] = false; //disable additional dialogue text
        padOverheatTextCD[1] = 2 * room_speed //set cooldown timer for dialogue text
        txt_font = fnt_game_bn_40_bold;
        txt_text = 'paddle overheat!';
        draw_set_font(txt_font)
        txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
        scr_popup_text_field_static(centerfieldx,centerfieldy - txt_height,
        txt_text,COLORS[10],txt_font)// fnt_menu_bn_40_bold 
             
        //maybe a sound would be good for this
    }
    //Decrement overheat text cooldown
    else if padOverheatTextCD[1] &gt; 0{
        padOverheatTextCD[1] -= 1;
    }
    //If threshold crossed re-enable overheat text
    else if !padOverheatTextCD[0] and padSpeed &gt; .75 * padSpeedDefault{
        padOverheatTextCD[0] = true;
    }
    
    
    
    //Tutorial Paddle Movement Accumulator
    if TUTORIAL_ENABLED and tutorialPaddleMovePercent &gt;= 0 and (!touchPad or touchPad == 3 or touchPad*SWIPE){
       tutorialPaddleMovePercent += abs(addToAngle)
    }
    
    
     
    //Update Inverted Mouseangle for Inversion Downer
    if POWER_invertcontrols[@ 0]{
    
        POWER_invertcontrols[@ 7] -= addToAngle
        while (POWER_invertcontrols[@ 7] &lt; 0) {
            POWER_invertcontrols[@ 7] += 360;
        }
        while (POWER_invertcontrols[@ 7] &gt; 360) {
            POWER_invertcontrols[@ 7] -= 360;
        }
    }
    
    
    
    // Update Mouseangle
    mouseangle += addToAngle * DELTA_TIME_SCALAR; 
    while (mouseangle &lt; 0) {
        mouseangle += 360;
    }
    while (mouseangle &gt; 360) {
        mouseangle -= 360;
    }

    //NewMAFromCenter = currentAngle//mouseangle; //Reset mouse angle for speed calcs
    //Apparently it's better if we use a fresh speed calc?
    
    
} 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Effects: shake, score count, combos, etc
if !GAME_PAUSE{

    // Ease Score Display Number Up to Real Score
    var toadd = sign(score_p1 - score_display);
    for(var i=0;i&lt;level;i++){
        for(var j=0;j&lt;string_length(string(score_p1));j++){
            toadd*=power(10,j)
            if abs(score_p1 - score_display) &gt;= toadd{//-.1{
                score_display += toadd
            }
        }
    }
    
    
    // Update Bomb Timers (Used for Bomb's Screenshake)
    scr_bomb_force_update();
    
  
    
    //shake = true; shaketime = 10; //DELETE ME
    if SHAKE_TIME &gt; 0{
        var shake_angle = irandom(359);
        //shake_str = 4;
        view_xview[0] = VIEW_X + round(dcos((shake_angle))*SHAKE_POWER)
        view_yview[0] = VIEW_Y + round(dsin((shake_angle))*SHAKE_POWER)
        
        // Play Shake Sound
        if !audio_is_playing(sd_screenshake) {scr_sound(sd_screenshake)}
        
        // Update Shake Time
        SHAKE_TIME -= 1
    }
    else if SHAKE_TIME &gt; -2{
        // If Screen is In Placc
        if ( (view_xview[0] - VIEW_X) + (view_yview[0] - VIEW_Y) ) == 0{
        
           // End Shake Sound
           if audio_is_playing(sd_screenshake) {
                audio_sound_gain(sd_screenshake,0,room_speed)
           }
           // Set Shake State to Inactive
           SHAKE_TIME = -2;
           // Reset Shake Power
           SHAKE_POWER = 0;
        }
        // Else Ease Screen Into Place
        else{ 
           view_xview[0] += sign(VIEW_X - view_xview[0])
           view_yview[0] += sign(VIEW_Y - view_yview[0])
        }
        
        /* NB: It might be cool to have tiers of screenshake.  e.g. 3-5 for small, 6-8 for large
         and 10-12 for giant.
         We could do it via a screenshake object.  But it's not super critical right now.
        
        */
    }
    
    
    //Decrement Cash Caught Timer
    if cashTimer &gt; 0{
        cashTimer--;
    }
    
    
    //POWERUP COMBOS EFFECT
    if global.pComboTimer &gt; 0 and MOVE_READY{
        // Decrement Combo Timer
        global.pComboTimer -=1
    }
    else if global.pComboCount &gt; 0 and ((MODE != MODES.MOVES) or (!MOVE_ACTIVE))
    {
        lastBestCombo = max(lastBestCombo,global.pComboCount)
        
        //If high count Spawn compliment text
        if global.pComboCount &gt;= 10
        {
            txt_num = irandom(array_length_2d(streak_words,0)-1);;
            txt_tier = irandom(array_height_2d(streak_words)-1);
            txt_color = irandom_range(0,4)//min(floor(global.pComboCount / 10 - 1),array_height_2d(streak_words)-1);
            //txt_color = max(5 -floor(global.pComboCount / 10 - 1),0);
            txt_text = streak_words[txt_tier,txt_num]//+'!'

            txt_text+= " x"+string(global.pComboCount);
            txt_font = fnt_game_bn_40_bold;
            draw_set_font(txt_font)
            txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
            //scr_popup_text_powers_new3(centerfieldx,centerfieldy, text, COLORS[txt_color],
            scr_popup_text_field_static(centerfieldx,centerfieldy - txt_height, 
            txt_text, COLORS[txt_color],txt_font, true, 3*room_speed)//fnt_game_bn_30_black
            scr_sound(sd_combo, 1, false);
        }
        
        //Restore current theme
        //scr_restore_color_theme();
        
        //Reset count
        global.pComboCount = 0
    }
    
    //Noves Mode : Board Clear Message
    if MODE == MODES.MOVES and moves_clear_messages != MOVES_REMAINING{
        //Decrement Moves clear messages
        moves_clear_messages--;
        
        txt_text = "cleared ";
        if instance_number(obj_reflector_parent) == 0 {
            txt_text = "perfect "
        }
        txt_text += string_format(round((1 - moves_board_end/moves_board_start) * 100),0,0) +"%";// +"!";

        txt_font = fnt_game_bn_40_bold;
        draw_set_font(txt_font)
        //txt_height = string_height(txt_text) * 1.1
        // Spawn Message in Center Position
        scr_popup_text_field_static(centerfieldx,centerfieldy,// - txt_height, 
        txt_text, COLORS[0],txt_font, true, 3*room_speed)//fnt_game_bn_30_black

    }
    
    // Show Near Miss Text
    if near_miss {
       //Reset NearMiss
       near_miss = false;

       txt_num = irandom(array_length_1d(near_miss_words)-1);
       txt_color = 0//irandom_range(0,4);
       txt_text = near_miss_words[txt_num]+'!'
       
       txt_font = fnt_game_bn_40_bold;
       draw_set_font(txt_font)
       //txt_height = string_height("H")*.6 + string_height(txt_text) / 2;
       //scr_popup_text_powers_new3(centerfieldx,centerfieldy, text, COLORS[txt_color],
       scr_popup_text_field_static(centerfieldx,centerfieldy, 
       txt_text, COLORS[txt_color],txt_font, true, 3*room_speed)//fnt_game_bn_30_black
       
       // Add Screenshake
       scr_shake_add(.5 * room_speed, 4);
       // Play Near Miss Sound
       scr_sound(sd_near_miss, 1, false);
    
    
    }

    
    /*
    /// Beat FX
    var_time_pass += delta_time
    if var_beat_time &lt;= var_time_pass{   
        var_time_pass -= var_beat_time
        var Beat_Type = string_char_at(var_beat_list,1)
        var_beat_list = string_delete(var_beat_list, 1, 1);
        scr_beat_effect(Beat_Type, .5)
    }*/
    

}



//GARBAGE COLLECTION FOR PARTICLES e.g. obj_star trail
var gc_size = ds_list_size(global.GC_particles)
    // NB: this block takes a list of arrays of timers and 
    //particles and destroys them when timer is 0
for (var i = gc_size-1; i&gt;=0; i-=1)
{
    // Get Particle Data
    var gc_array = global.GC_particles[| i];
    // Decrement Timer
    gc_array[@ 1] -= 1;
    if gc_array[1] &lt; 0
    {
       part_type_destroy(gc_array[0]);
       ds_list_delete(global.GC_particles,i);
    }
    //else{global.GC_particles[| i] = gc_array}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///GameOver, Pause Init

//Gameover stuff
if !GAME_PAUSE{
    if GAME_ACTIVE{
        if MODE == MODES.ARCADE and lives &lt;= 0 {
            scr_gameover_init() // 
        }
        else if MODE == MODES.MOVES and MOVES_REMAINING &lt;= 0{         
            scr_gameover_init() //
        }
        else if MODE == MODES.TIME and time_left &lt;= 0 and !instance_number(obj_star){
            scr_gameover_init() //
        }
        else if MODE == MODES.SANDBOX and sandbox_gameover[0] and !instance_number(obj_star){
            scr_gameover_init() 
        }
    }
}
//Pause game stuff
if !GAMEOVER{

    pause_color = COLORS[0];
    pause_scale = 1;
    //Set Pause Hover if less than distance
    pause_hover = 64*RU &gt; point_distance(mouse_x,mouse_y,
                            x_gui-x_gui_adj1, mode_bar_y-barheight+20)
    if pause_hover{
        //To prevent TP from moving to a button
        tp_on_button[0] = 2;
    }
    
    if !GAME_PAUSE and 
    ((pause_hover and mouse_check_button(mb_left)) or 
      keyboard_check_released(ord('P')) or 
      keyboard_check_released(vk_backspace) or 
     (TOUCH_ENABLED and os_is_paused() ))
    {
        
        if mouse_check_button_pressed(mb_left) //mouse_check_button _released(mb_left) 
           or keyboard_check_released(ord('P'))
           or keyboard_check_released(vk_backspace)
           or (touchPad == 1 and os_is_paused()) 
        {
              GAME_PAUSE = true
              SWIPE = false; // disable other clicks
              mouse_clear(mb_left);
              keyboard_clear(ord('P'));
              keyboard_clear(vk_backspace);
              objPause = instance_create(0, 0, obj_control_pause);
              with(objPause){
                scr_sound(sd_menu_click,1,false);
              }
        }
        pause_color = merge_color(COLORS[0],COLORS[6],.5);
        pause_scale = 1.2;
        
        // Pause Event Analytics
        analytics_send_pause_stats();
        
    }
    else if GAME_PAUSE {pause_scale = 1.2/*pause_color = merge_color(COLORS[0],COLORS[6],.5)*/} //lightens during PAUSE
}

    
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Averaging FPS
/*
if STEP mod 100 == 0
{
    ds_list_add(global.fpslist,fps);
    global.fpsavg = ds_list_mean(global.fpslist)

}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///debugger effects
/*
if mouse_check_button_pressed(mb_right){

    show_message(string(window_get_height()))
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///debugger, Spawn Star, Extra Cash

if keyboard_check(vk_shift){

    //As long as we're in game
    if GAME_ACTIVE = true{
    
        if mouse_check_button_released(mb_middle) and MOVE_READY //released
        {
            // Get Grid Loc of Mouse
            var tempXY = convertXYtoGrid(mouse_x,mouse_y);
            // Round
            tempXY[0] = round(tempXY[0]);
            tempXY[1] = round(tempXY[1]);
            // Convert to Field XY
            tempXY = convertGridtoXY(tempXY[0],tempXY[1]);
            
            
            for(var i = 0; i &lt; 8; i++){
                spawn_star(i*45,tempXY[0],tempXY[1])
            }
        }
    
    }
    if keyboard_check_pressed(vk_right){
        STAR_CASH+=100;
    }
    else if keyboard_check_pressed(vk_left ){
        STAR_CASH-=100;
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dynamic Aimer [unused]


/*
if !MOVE_ACTIVE and MODE == 2{// or true{
   //maybe this doesn't run during tutorial?
   scr_update_dynamic_aimer()
}
else if booster_Aimer{//booster_Aimer would be used here normally.
   scr_update_dynamic_aimer2()
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///GUI, Intro Text

if !GAMEOVER { 
    draw_set_colour(COLORS[0]);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    
    x_score = GAME_X+10 -100*(1 -scoreTween[0])//10//GAME_X + GAME_W;
    y_score = GAME_Y+5  -100*(1 -scoreTween[0])//oy +(fieldH+railset*1)*cellH
    x_gui = GAME_X + GAME_W -10 +100*(1 -scoreTween[0])//GAME_X+4
    y_gui = GAME_Y + GAME_H -10 //GAME_X+4
    halfbarwidth = 128 * scoreTween[0]//(RAIL_ANGLES[0]/90)*(fieldW)*.5*cellW*.8*scoreTween[0]; //15*cellW/2*scoreTween[0];
    barheight = 22//20; //15*cellW/2*scoreTween[0];
    mode_bar_x = centerfieldx
    mode_bar_y =  y_score +30 //-barheight/2//padcentery - ((GAME_Y + GAME_H)-padcentery)+7
    pTimer = max(0,global.pComboTimer/global.pComboTimerMax);
    
    //DRAW SCOREBOARD
    draw_set_font(fnt_game_bn_26_black);
    score_col = COLORS[0];
    // Use Power Color During Combo
    if pTimer &gt; .25 {
        score_col = COLORS[global.pComboColor]
    }
    // Use Bomb Color For GUI During Shake
    if SHAKE_TIME + global.BOMB_FORCE &gt; 0 {
        score_col = COLORS[4]
    }
    y_adj_score = y_score;
    draw_text_color(x_score, y_adj_score, "score",COLORS[0],COLORS[0],COLORS[0],COLORS[0],1);
    y_adj_score += string_height('S'); //adjust with previous font height
    // DRAW SCORE VALUE
    draw_set_font(fnt_game_bn_20_black);
    draw_text_colour(x_score+gui_jiggle[0,1], y_adj_score+gui_jiggle[0,2], 
        string(score_display),score_col,score_col,score_col,score_col,1);
        //NB: We could use a thinner x scale iF the string len gets too big.
        
        
    // DRAW CASH VALUE
    if VC_ENABLED {
        // Saved starcash, points based starcash (unused), caught starcash
        var cash_val = STAR_CASH;// 
        //cash_val_from_this_game = starCashEarned + starCashCaught;
        var cash_str = CASH_STR+string_abbrev_real_mag(cash_val,2,4);
        var cash_col = COLORS[0]; 
        if cashTimer &gt; 0 {cash_col = COLORS[3]}
        y_adj_score += string_height("H");
        
        draw_text_colour(x_score+gui_jiggle[2,1], 
        y_adj_score+gui_jiggle[2,2], 
        cash_str,cash_col,cash_col,cash_col,cash_col,1);
    }
    
    
    
    //COMBO TEXT BOTTOM LEFT
    if global.pComboCount &gt; 1{
        draw_set_font(fnt_game_bn_20_black);draw_set_valign(fa_bottom);draw_set_halign(fa_left);
        /*
        // Jiggle for Combo Text, deemed unnecessary
        var pJiggler;
        pJiggle[0] = 0
        pJiggle[1] = 0
        if pTimer &gt; .75{
            var pJiggleStrength = 3;
            pJiggle[0] = random_range(-1,1)*pJiggleStrength;
            pJiggle[1] = random_range(-1,1)*pJiggleStrength;
        }*/
        //'combo #x'+string(global.pComboCount)
        draw_text_colour(x_score/*+pJiggle[0]*/,fieldEndYP/*+pJiggle[1]*/,'x'+string(global.pComboCount)+'#combo',
        COLORS[global.pComboColor],COLORS[global.pComboColor],
        COLORS[global.pComboColor],COLORS[global.pComboColor],
        pTimer);
    }
    
    
    
    
    //DRAW PAUSE BUTTON
    draw_set_halign(fa_right);draw_set_valign(fa_top);draw_set_font(fnt_game_bn_26_black);
    x_gui_adj1 = 40*.5; //the icons draw centered so we adjust by their size 40 div 2
    //standardized icon sprites to 40x40 pixels
    //draw_circle(x_gui-x_gui_adj1, y_score+22,100,false); 
    draw_sprite_ext(sp_pause,0,x_gui -x_gui_adj1, mode_bar_y-barheight+20,
    40/64*pause_scale,40/64*pause_scale,0,pause_color,1); 
    var x_gui_adj2 = x_gui_adj1*2 + sprite_get_width(s_v_star_white)*.2;
    
    
    
    
    
        
    //DRAW WIDE BAR 2 PIXELS; RIGOR 
    /*draw_rectangle_colour(mode_bar_x - halfbarwidth, mode_bar_y-barheight,mode_bar_x +halfbarwidth, 
                           mode_bar_y, COLORS[0], COLORS[0], COLORS[0], COLORS[0],1)
    draw_rectangle_colour(mode_bar_x - halfbarwidth+1, mode_bar_y-barheight+1,mode_bar_x +halfbarwidth-1, 
                           mode_bar_y-1, COLORS[0], COLORS[0], COLORS[0], COLORS[0],1)*/
    var out_barscale = 2*halfbarwidth / sprite_get_width(spr_bar_out);
    draw_sprite_ext(spr_bar_out,0,mode_bar_x - halfbarwidth, mode_bar_y, out_barscale,1,0,mode_bar_color,1);
    
    //DRAW BAR SIDE TEXT
    draw_set_font(fnt_game_bn_20_black)
    draw_set_valign(fa_bottom); 
    var side_text_w_adj = halfbarwidth + string_width("H")*.5; //8
    var slide_text_y = mode_bar_y
    draw_set_halign(fa_left)  
    draw_text_color(mode_bar_x + side_text_w_adj,slide_text_y,string(level+1),COLORS[0],COLORS[0],COLORS[0],COLORS[0],1)
    draw_set_halign(fa_right)          
    draw_text_color(mode_bar_x - side_text_w_adj,slide_text_y,string(level),COLORS[0],COLORS[0],COLORS[0],COLORS[0],1)
    
  
    //DRAW LIVES COUNT
    Lives_icon_y = fieldEndYP - 32/2//+2  s_v_deflector_coin0
    Lives__x = x_gui -x_gui_adj1*2//x_gui -string_width(string(lives))-x_gui_adj*1.5
    Lives__y = fieldEndYP//y_score+42
    
    
    //DRAW ARCADE MODE GUI
    if MODE == MODES.ARCADE{
        //DRAW LIVES COUNT
        draw_set_valign(fa_bottom);
        var staricon_scale = 40/sprite_get_width(s_v_penalty_white)//.4
        draw_sprite_ext(s_v_star_white,0,x_gui -x_gui_adj1+gui_jiggle[1,1], Lives_icon_y/*y_score+22*/+gui_jiggle[1,2],
        staricon_scale,staricon_scale,0,COLORS[0],1); 
        draw_set_font(fnt_game_bn_26_black) 
        draw_text_color(Lives__x+gui_jiggle[1,1],Lives__y+gui_jiggle[1,2], 
         string(lives),COLORS[0],COLORS[0],COLORS[0],COLORS[0],1);  
         
    
        
        //COMPUTE BAR FILL                         
        //var total_bar = 2*halfbarwidth
        //var prog_bar = min(1,(score-lastLevelScore)/(levelScore-lastLevelScore))*total_bar
        
        //DRAW FILLED BAR
        /*draw_rectangle_colour(mode_bar_x - halfbarwidth, mode_bar_y-barheight,mode_bar_x - halfbarwidth + prog_bar, 
                               mode_bar_y, COLORS[0], COLORS[0], COLORS[0], COLORS[0],0)*/
                               
        var prog_bar = min(1,(score-lastLevelScore)/(levelScore-lastLevelScore));
        var fill_barscale = out_barscale * prog_bar
        draw_sprite_ext(spr_bar_in,0,mode_bar_x - halfbarwidth,mode_bar_y,fill_barscale, 1,0,mode_bar_color,1);
                               
               
    }
    
    
    
    //DRAW MOVES MODE GUI
    if MODE == MODES.MOVES{
        //DRAW MOVES COUNT
        draw_set_valign(fa_bottom);
        var staricon_scale = 40/sprite_get_width(s_v_star_white)//.4
        draw_sprite_ext(s_v_star_white,0,x_gui -x_gui_adj1+gui_jiggle[1,1], Lives_icon_y+gui_jiggle[1,2],
        staricon_scale,staricon_scale,0,COLORS[0],1);  
        draw_set_font(fnt_game_bn_26_black) 
        draw_text_color(Lives__x+gui_jiggle[1,1],Lives__y+gui_jiggle[1,2], 
         string(MOVES_REMAINING),COLORS[0],COLORS[0],COLORS[0],COLORS[0],1);   
        
        //COMPUTE BAR FILL                        
        //var total_bar = 2*halfbarwidth
        //var prog_bar = min(1,(score-lastLevelScore)/(levelScore-lastLevelScore))*total_bar
        
        //DRAW FILLED BAR
        /*draw_rectangle_colour(mode_bar_x - halfbarwidth, mode_bar_y-barheight,mode_bar_x - halfbarwidth + prog_bar, 
                               mode_bar_y, COLORS[0], COLORS[0], COLORS[0], COLORS[0],0)*/
                               
        //var prog_bar = min(1,(score-lastLevelScore)/(levelScore-lastLevelScore));
        var prog_bar = max(0,min(1,(moves_time_left)/(moves_time_max)));
        var fill_barscale = out_barscale * prog_bar
        //draw_sprite_ext(spr_bar_in,0,mode_bar_x - halfbarwidth,mode_bar_y,fill_barscale, 1,0,COLORS[0],1);
        draw_sprite_ext(spr_bar_in,0,mode_bar_x - halfbarwidth,mode_bar_y,fill_barscale, 1,0,mode_bar_color,1);
        
        
        //DRAW TIME REMAINING TEXT ABOVE BAR
        draw_set_font(fnt_game_calibri_16_bold)
        draw_set_halign(fa_center) 
        draw_set_valign(fa_middle);
        //draw_text_outline_color(mode_bar_x,mode_bar_y-26,time_string,c_time,c_time,c_time,c_time,1,
        draw_text_outline_color(mode_bar_x,mode_bar_y-barheight/2 +1,moves_time_string,
        COLORS[6],COLORS[6],COLORS[6], COLORS[6],1,4,mode_bar_color,16)
        //c_moves_time,c_moves_time,c_moves_time,c_moves_time,1,4,COLORS[0],16)  
    }
    
    //DRAW TIME MODE GUI
    if MODE == MODES.TIME{ 
        //DRAW FOULS COUNT
        draw_set_valign(fa_bottom);
        var staricon_scale = 40/sprite_get_width(s_v_penalty_white)//.4
        draw_sprite_ext(s_v_penalty_white,0,x_gui -x_gui_adj1+gui_jiggle[2,1],
        Lives_icon_y+gui_jiggle[2,2],staricon_scale,staricon_scale,0,COLORS[0],1); 
        draw_set_font(fnt_game_bn_26_black) 
        draw_text_color(Lives__x+gui_jiggle[2,1],Lives__y+gui_jiggle[2,2], //This could have its own jiggle var based on penalty increment.  Simple to add, we can do it when we start fixing timemode
        string(time_penalty),COLORS[0],COLORS[0],COLORS[0],COLORS[0],1);  
        
    
                               
        //COMPUTE BAR FILL               
        //var total_bar = 2*halfbarwidth
        //var prog_bar = max(0,min(1,(time_left)/(time_max)))*total_bar
        
        //DRAW FILLED BAR
        /*draw_rectangle_colour(mode_bar_x - halfbarwidth, mode_bar_y-barheight,mode_bar_x - halfbarwidth + prog_bar, 
                               mode_bar_y, COLORS[0], COLORS[0], COLORS[0], COLORS[0],0)*/
        var prog_bar = max(0,min(1,(time_left)/(time_max)));
        var fill_barscale = out_barscale * prog_bar
        draw_sprite_ext(spr_bar_in,0,mode_bar_x - halfbarwidth,mode_bar_y,fill_barscale, 1,0,mode_bar_color,1);
        
        
        //DRAW TIME REMAINING TEXT ABOVE BAR
        draw_set_font(fnt_game_calibri_16_bold)
        draw_set_halign(fa_center) 
        draw_set_valign(fa_middle);
        //draw_text_outline_color(mode_bar_x,mode_bar_y-26,time_string,c_time,c_time,c_time,c_time,1,
        draw_text_outline_color(mode_bar_x,mode_bar_y-barheight/2 +1,time_string,
        COLORS[6],COLORS[6],COLORS[6],COLORS[6],1,4,mode_bar_color,16)
        
    }
    //DRAW SANDBOX MODE GUI
    if MODE == MODES.SANDBOX{ 
        //DRAW FOULS COUNT
        draw_set_valign(fa_bottom);
        var staricon_scale = 40/sprite_get_width(s_v_penalty_white)//.4
        draw_sprite_ext(s_v_penalty_white,0,x_gui -x_gui_adj1+gui_jiggle[2,1],
        Lives_icon_y+gui_jiggle[2,2],staricon_scale,staricon_scale,0,COLORS[0],1);
        draw_set_font(fnt_game_bn_26_black)  
        draw_text_color(Lives__x+gui_jiggle[2,1],Lives__y+gui_jiggle[2,2], //This could have its own jiggle var based on penalty increment.  Simple to add, we can do it when we start fixing timemode
        string(lastDeaths),COLORS[0],COLORS[0],COLORS[0],COLORS[0],1);  
        
    
        
        //COMPUTE BAR FILL                         
        //var total_bar = 2*halfbarwidth
        //var prog_bar = min(1,(score-lastLevelScore)/(levelScore-lastLevelScore))*total_bar
        
        //DRAW FILLED BAR
        /*draw_rectangle_colour(mode_bar_x - halfbarwidth, mode_bar_y-barheight,mode_bar_x - halfbarwidth + prog_bar, 
                               mode_bar_y, COLORS[0], COLORS[0], COLORS[0], COLORS[0],0)*/
        var prog_bar = min(1,(score-lastLevelScore)/(levelScore-lastLevelScore));
        var fill_barscale = out_barscale * prog_bar
        draw_sprite_ext(spr_bar_in,0,mode_bar_x - halfbarwidth,mode_bar_y,fill_barscale, 1,0,mode_bar_color,1);
                               
               
    }
        
    // Reset Bar Color
    mode_bar_color = COLORS[0];
        //NB: Useful for switching themes mid game
        
         
        
    
    
    /*
    ///Draw Touch Trail
    if touchPad{ 
       //If new SWIPE, use new array of coordinates
       if TouchTrailInit and SWIPE{
            //toggle flag
            TouchTrailInit = false;
            //create new array to pass into trail script
            var TouchTrailNew = noone;
            TouchTrailNew[0,0] = 0;
            TouchTrailArray = TouchTrailNew;
            
       }
       //else set flag to use new array next time
       else if !SWIPE and !TouchTrailInit{
            TouchTrailInit = true;
       }
       //If SWIPE add the mouse coordinates
       if SWIPE{
            TouchMX = mouse_x;
            TouchMY = mouse_y;
       }
       //else use old coordinates
    
       draw_trail_swipe_player(TouchMX,TouchMY,20,8,COLORS[0],-1,true,1,TouchTrailArray)  
       //then we can have a flag that checks if the first and last points xy are the same
       //with a len check to use the right thing
       //and if they are then it doesn't draw
       //to be honest in practice this was no an issue on touchpads oh dear..
       
       
       
       //we could make this fancier by not adding points to the array after a gameover flag
       //we'd put the condition inside the script where the array indexes are added and changed.
       //but i think for now it's ok.
    }*/
    
    //Draw TouchPad
    if touchPad != 0 and 
       TOUCH_PAD_SHOW and 
       tp_scale[0] &gt; 0 and 
       instance_exists(paddle_id)
    {
       
        var tp_is_on_a_button = tp_on_button//array_sum_1d(tp_on_button);
        
        if tp_is_on_a_button[0] == 0{
            tp_big_x += (dynamicCenterX - tp_big_x) * .2;
            tp_big_y += (dynamicCenterY - tp_big_y) * .2; 
        } 
        
        
        // If TP Not Tweening
        if !TweenExists(tp_tween) and (!TUTORIAL_STARTED[0] or tp_dummy){
            //Brighten and Grow on Taps (Tween Bounce)
            if SWIPE_TAP and tp_scale[0] == 1{
                //Tween up alpha and tp_scale
                tp_tween = TweenFire(id, tp_scale, EaseLinear,
                                TWEEN_MODE_BOUNCE,1, 0, .1,  tp_scale[0], 1.25)
                tp_tween_alpha = TweenFire(id, tp_alpha, EaseLinear,
                                TWEEN_MODE_BOUNCE,1, 0, .1,  1, 1.75)
                //TweenDestroyWhenDone(tp_tween,true, false)
                //TweenDestroyWhenDone(tp_tween_alpha,true, false)
                //scr_sound(sd_menu_click);
    
            }
            // If Sensitivity was changed in options
            if TP_SENSE[3] == 2 {
                //Clear State for Sensitivity 
                TP_SENSE[3] = 0;
                //Tween to New Sensitivity
                tp_tween = TweenFire(id, tp_scale,EaseLinear,
                                TWEEN_MODE_ONCE, 1, 0, .5, tp_scale[0], 1) 
            }
        }
        
        
        // Set Touch Pad Radii
        tp_set_radii();
     
        // Get Touch Pad Color
        tp_col = paddle_id.padColor[0]
        
        // Draw Base Touch Pad
        var tp_base_scale = 2*tp_bigR / sprite_get_width(spr_tp_base_out);
        draw_sprite_ext(spr_tp_base_out,0,tp_big_x,tp_big_y,
            tp_base_scale,tp_base_scale,0,tp_col,clamp(.6*tp_alpha[0],0,1));
        draw_sprite_ext(spr_tp_base_in,0,tp_big_x,tp_big_y,
            tp_base_scale,tp_base_scale,0,tp_col,clamp(.25*tp_alpha[0],0,1));
    
        
        // Update Distance Of TouchPad from Center
        if (mouse_check_button(mb_left) and SWIPE_BRK) or (tp_dummy){
            // If Linear Controls
            if TP_SENSE[1] == 2 {
                tp_dist = tp_bigR - tp_smlR; //EVALUATE ME
            }
            // If Not Line Controls
            else{
                //Don't update tp_dist if PAUSE button touched
               if tp_is_on_a_button[0] == 0{
                  tp_dist = min(tp_dist_max,point_distance(tp_big_x, tp_big_y, oldMX, oldMY));
               }
           } 
           //You could ease this down to zero in the Else block like a real joystick, 
           //but it's probably more intuitive/instructive if you don't.
        }
           
        var tp_adj_x, tp_adj_y, tp_angle;
        // Get Angle of Touch Pad Top from Base Center
        if !POWER_invertcontrols[@ 0]{
           tp_angle = -1*mouseangle;
        } 
        //Paddle Inversion Powerdown Scenario  
        else{
             tp_angle = -1*POWER_invertcontrols[@ 7];
        }
           
        tp_sml_x += (tp_big_x+lengthdir_x(tp_dist,tp_angle) - tp_sml_x) * .4;
        tp_sml_y += (tp_big_y+lengthdir_y(tp_dist,tp_angle) - tp_sml_y) * .4;  
        
        // Draw Touch Pad Top
        var tp_top_scale = 2*tp_smlR / sprite_get_width(spr_tp_top_out);
        draw_sprite_ext(spr_tp_top_out,0,tp_sml_x,tp_sml_y,
            tp_top_scale,tp_top_scale,0,tp_col,clamp(.65*tp_alpha[0],0,1));
        draw_sprite_ext(spr_tp_top_in,0,tp_sml_x,tp_sml_y,
            tp_top_scale,tp_top_scale,0,tp_col,clamp(.45*tp_alpha[0],0,1));
    
        
    }
    
    
    // Draw Game Intro Sub text/////////////////////
    if !GAMEOVER and GAME_ACTIVE and scoreTween[0] == 1 {
        if (!MOVE_ACTIVE and !TUTORIAL_ENABLED) and 
            introTextEase[0] == 0 and !TweenExists(introTextTween) {
            // Ease In Intro Text
            TweenFire(id, introTextEase, EaseLinear, 
                TWEEN_MODE_ONCE, true, 0, .25, introTextEase[0], 1);
                
            // Set Quest Text    
            if QUEST_DATA[3] &gt; 0 and QUEST_DATA[2] &lt; QUEST_DATA[1] {
                quest_text_cache = "Quest: " + scr_quest_text(0, scr_quest_progress());
                //New Quest?
                if QUEST_DATA[3] == 1 
                {
                    quest_text_cache = "New " + quest_text_cache;
                    // If First Quest and First Display
                    if QUEST_DATA[4] &lt; 1 and QUEST_DATA[3] == 1
                    {
                        //Mention that they can be cancelled
                        quest_text_cache += "##" + "Quests can be cancelled from the pause menu.";
                    }
                }
            } else {
                quest_text_cache = "";
            }
        }
        else if (MOVE_ACTIVE or TUTORIAL_STARTED[0]) and 
            introTextEase[0] &gt; 0 and !TweenExists(introTextTween) {
            // Ease Out Intro Text
            TweenFire(id, introTextEase, EaseLinear, 
                TWEEN_MODE_ONCE, true, 0, .25, introTextEase[0], 0);
        }
    }
    // Draw Intro Text
    if introTextEase[0] != 0 {
        //Display tap to begin text
        draw_set_font(fnt_game_calibri_25_bold);
        draw_set_valign(fa_middle);
        draw_set_halign(fa_center);
        
        text_y_top = fieldEndY +60;
        text_y_bottom = GAME_Y+GAME_H -20 ;
        text_y = (text_y_top + text_y_bottom)/2 +75* (1 -introTextEase[0]);
        
        text_x = GAME_MID_X;
        text_w = (GAME_W* 11/32 * 2);
        
        text_alpha = clamp(introTextEase[0],0,1); //clamp((1 - lastPlaytime/room_speed),0,1)
        text_color = COLORS[0];
        
        text_display = false;   
        
        // Set Starting Dialogue Text for Arcade and Time
        if MODE != MODES.MOVES and MODE != MODES.SANDBOX{
            text_text = "Take aim and tap to begin.";
            text_display = true;
        }
        // For Moves and Sandbox it's more complicated
        else
        {
            //Check that no star markers are selected
            sMSelected = false;
            with (obj_star_marker){
                 if selected[0]{
                    other.sMSelected = true; 
                    break;
                 }
            }
            
            // Check that no board modifier is selected
            if bMSelected[0] == noone and !sMSelected and !ScheduleExists(bMScheduler)
            and bMtext[array_length_1d(bMtext)-1] &lt;= 0{
            
                text_y = (mixers_y[mixPos[0]]+GAME_Y+GAME_H)/2;
                text_alpha *= clamp(MixersEase[0],0,1);
                
                text_text = "Modify the board or place a star and tap anywhere to begin.";
                
                text_display = true;
            }
        }
        // Display Starting Dialogue Text
        if text_display {
            
            
            // Append Quest Text
            if quest_text_cache != "" and MOVE_COUNT &lt;= 1 {
                text_text = quest_text_cache + "##" + text_text;
            } 
            
            draw_text_ext_transformed_colour(text_x,text_y,text_text,-1,text_w,1,1,0,
            text_color,text_color,text_color,text_color,text_alpha);
        
        }
    }
    
    
    
    //Decrement GUI jigglers
    var jiggle_strength = 5;
    for (var i=0, n=array_height_2d(gui_jiggle); i &lt; n; i++){
        if gui_jiggle[i,0] &gt; 0{
            gui_jiggle[i,0] -= 1
            gui_jiggle[i,1] = random_range(-1,1)*jiggle_strength;
            gui_jiggle[i,2] = random_range(-1,1)*jiggle_strength;
        }
        else if gui_jiggle[i,0] &gt;= -1{
            gui_jiggle[i,0] = -2
            gui_jiggle[i,1] = 0;
            gui_jiggle[i,2] = 0;
        
        }
    }



}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw dynamic aimer [disabled]
/*

if !MOVE_ACTIVE and MODE == 2 and MOVE_READY{
   scr_draw_dynamic_aimer()
}
else if booster_Aimer{//booster var would go here
   scr_draw_dynamic_aimer2()
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw_fps
/*
draw_text(padcenterx,padcentery,'avgFPS: '+string(global.fpsavg))

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debugger

/*
draw_set_font(fnt_game_bn_30_black);
draw_text_colour(mouse_x,mouse_y, string(delta_time / delta_time_expected),
COLORS[0],COLORS[0],COLORS[0],COLORS[0],1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
