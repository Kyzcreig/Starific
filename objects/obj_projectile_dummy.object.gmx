<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>50</depth>
  <persistent>0</persistent>
  <parentName>obj_parent_dummy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ini vars
scene_alpha = obj_control_tutorial.tutorialTextTween[0];
//pass in the top and bottom on create
scene_top = 0//+sprite_gap; //grab this from creation
scene_bottom = GAME_Y+GAME_H;

//Calculate the x,y, of the fake paddle
paddle_x = GAME_MID_X;
//i'll need about 120 for the cooldown icon so it has breathing space
paddle_y = scene_bottom - 160;
paddle_w = 256;
paddle_h = PADDLE_H;

paddle_jiggler = 0;

//Symbols and types for projectiles
var i = -1;var j = -1;var k = 4;
//3 upgrades
projType[++i,(++j)mod k] = spr_power_grow;
projType[i,(++j)mod k] = 1;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_ups);
projType[i,(++j)mod k] = 'bigger#paddle!'

projType[++i,(++j)mod k] = spr_power_slower;
projType[i,(++j)mod k] = 1;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_ups);
projType[i,(++j)mod k] = 'slow#stars!'

projType[++i,(++j)mod k] = spr_power_pmulti;
projType[i,(++j)mod k] = 1;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_ups);
projType[i,(++j)mod k] = 'extra#points!'
//3 downgrades
projType[++i,(++j)mod k] = spr_power_shrink;
projType[i,(++j)mod k] = 2;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_downs);
projType[i,(++j)mod k] = 'smaller#paddle!'

projType[++i,(++j)mod k] = spr_power_faster;
projType[i,(++j)mod k] = 2;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_downs);
projType[i,(++j)mod k] = 'fast#stars!'

projType[++i,(++j)mod k] = spr_power_pdivis;
projType[i,(++j)mod k] = 2;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_downs);
projType[i,(++j)mod k] = 'less#points!'
//3 sidegrades
projType[++i,(++j)mod k] = spr_power_hugestar;
projType[i,(++j)mod k] = 1;//3;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_ups);
projType[i,(++j)mod k] = 'super#star!'

projType[++i,(++j)mod k] = spr_power_0angle;
projType[i,(++j)mod k] = 2//3;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_downs);
projType[i,(++j)mod k] = 'no turns!'

projType[++i,(++j)mod k] = spr_cash_x2;
projType[i,(++j)mod k] = 3;
projType[i,(++j)mod k] = object_get_sprite(obj_powerup_parent_neutral);
projType[i,(++j)mod k] = 'cash#doubler!'
//current projType
projCur = irandom(array_height_2d(projType)-1);

//Duration of projectile flying
durProjectile = 1.5*room_speed;
//Duration until reloop
durCooldown = 3*room_speed;
//Time counter
durTimer = 0;
durTotal = durProjectile+durCooldown;

proj_scale = obj_control_game.pFallingSize/sprite_get_height(projType[projCur,2]);
proj_sym_scale = cellW/60 * obj_control_game.pFallingScalar;
proj_start_x = paddle_x
proj_start_y = scene_top + obj_control_game.pFallingSize/2;
proj_x = proj_start_x;
proj_y = proj_start_y;

proj_speed = (paddle_y-proj_start_y) / durProjectile
proj_dir = 270;
proj_rot = (proj_dir +270) mod 360;

proj_state = 0; //0=only projectile, 1= both, 2= only cooldown icon

proj_spr_color = power_type_colors(projType[projCur,1],0);
proj_sym_color = power_type_colors(projType[projCur,1],1);


cooldown_x = paddle_x;
cooldown_y = paddle_y + paddle_h*3;

cooldown_jiggler = 0;
cooldown_text = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///projectile particle create


proj_particle = part_type_create();
part_type_sprite(proj_particle,projType[projCur,2],0,0,0);
part_type_size(proj_particle,1,1,-0.01*RMSPD_DELTA,0*RMSPD_DELTA);
part_type_scale(proj_particle,proj_scale,proj_scale);
part_type_color1(proj_particle,c_white);
part_type_alpha2(proj_particle,1,0.2);
//part_type_speed(proj_particle,1*RMSPD_DELTA,1*RMSPD_DELTA,0*RMSPD_DELTA,0*RMSPD_DELTA);
//part_type_direction(proj_particle,0,359,0*RMSPD_DELTA,0*RMSPD_DELTA);
//part_type_gravity(proj_particle,0*RMSPD_DELTA,270);
//part_type_blend(proj_particle,0);
//part_type_orientation(proj_particle,image_angle,image_angle,0*RMSPD_DELTA,0*RMSPD_DELTA,0);
part_type_orientation(proj_particle,proj_rot,proj_rot,0*RMSPD_DELTA,0*RMSPD_DELTA,1);
//part_type_life(p_spr_fall,room_speed*5,room_speed*5);
part_type_life(proj_particle,durProjectile/2,durProjectile/2);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///particle death and garbage collect particle

if part_type_exists(proj_particle)
{
   var gc_array = 0;
   gc_array[0] = proj_particle;
   gc_array[1] = 1*room_speed;
   ds_list_add(global.GC_particles,gc_array);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Calculate scene params
///Scene iteration

scene_alpha = obj_control_tutorial.tutorialTextTween[0];




if scene_alpha == 1{    
    
    //Initialize random power object for scene
    if durTimer == 0{
        projCur = irandom(array_height_2d(projType)-1);
        proj_y = proj_start_y;
        proj_state = 0;
        
        //Set new Particle Effect Trail sprite
        part_type_sprite(proj_particle,projType[projCur,2],0,0,0);
        
        //Set Colors
        proj_spr_color = power_type_colors(projType[projCur,1],0);
        proj_sym_color = power_type_colors(projType[projCur,1],1);
        
        //Create Particle Effect -- Spawn
        particleCount = round(scr_particle_explosion_count(0)*2)
        //part_type_orientation(p_destroy_ring_long,0,359,random_range(-2.5,2.5),0,1); //rangerandom(-2,2);
        part_type_orientation(p_destroy_ring_long,0,359,0,0,1); //rangerandom(-2,2);
        part_particles_create_color(PSYS_FIELD_LAYER, proj_x, proj_y, p_destroy_sparkles_long, proj_spr_color, particleCount);//1
        part_particles_create_color(PSYS_FIELD_LAYER, proj_x, proj_y, p_destroy_ring_long, proj_spr_color,1);
    }
    
    //Increment scene timer
    durTimer = (durTimer + 1) mod (durTotal);
    
    //Advance scene and spawn particle effects
    if proj_state == 0{ //durTimer &lt;= durProjectile and durTimer &gt; 0{
        proj_y = proj_start_y + proj_speed*durTimer;
        //Particle trail
        var partCount = 20;//how many particles during scene?
        var partMod = round(durProjectile/partCount); 
        if (durTimer mod partMod) == 0 {
            //Create particle trail effect
            part_particles_create_colour(PSYS_FIELD_LAYER,proj_x,proj_y,
            proj_particle,proj_spr_color,1);
        }

        
        if proj_y &gt; paddle_y and proj_state == 0{
            proj_state = 2;
            //Create Particle Effect Death
            if projType[projCur,1] == 1{
                part_particles_create_color(PSYS_SUBSTAR_LAYER, proj_x, proj_y, p_catch_good,proj_spr_color, 200);
            } 
            else if projType[projCur,1] == 2{
                part_particles_create_color(PSYS_SUBSTAR_LAYER, proj_x, proj_y, p_catch_bad,proj_spr_color, 100);
                paddle_jiggler = room_speed *.25
            
            } 
            else if projType[projCur,1] == 3{
                part_particles_create_color(PSYS_SUBSTAR_LAYER, proj_x, proj_y, p_catch_neutral,proj_spr_color, 150);
            
            } 
            //Play appropriate sound
            scr_catch_power_sound(noone,projType[projCur,1]);
            
            
            cooldown_jiggler = room_speed *.5
            cooldown_text = durCooldown * 1 //.8//.5;
            
                    //if we want to tween it's straight forward
                    //we can add that later
                    //we can use states 1 and 3 for interstitial states so both draw
        }
    }

}


if !TUTORIAL_ENABLED or obj_control_tutorial.tutorialTitleTween[0] != 1 //or !tutorialActive[0]// 
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy

instance_destroy()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Scene


//Draw Paddle
var sp_xscale = paddle_w / 128;
var sp_yscale = PADDLE_H / 128;
var paddle_jig_x = 0;
var paddle_jig_y = 0;
if paddle_jiggler &gt; 0{
    paddle_jiggler -= 1;
    var jiggle_strength = 6;
    paddle_jig_x = random(1)*jiggle_strength;
    paddle_jig_y = random(1)*jiggle_strength;
}

draw_sprite_ext(s_v_background_solid,0,paddle_x-paddle_w/2+paddle_jig_x, paddle_y+paddle_jig_y,
sp_xscale, sp_yscale, 0, COLORS[0],scene_alpha);


//Draw Projectile
if (proj_state mod 3) &lt;= 1{
    //draw deflector
    draw_sprite_ext(projType[projCur,2],0,proj_x, proj_y,
    proj_scale, proj_scale, proj_rot, proj_spr_color,scene_alpha);
    //draw symbol
    draw_sprite_ext(projType[projCur,0],0,proj_x, proj_y,
    proj_sym_scale, proj_sym_scale, 0, proj_sym_color,scene_alpha);
}
//Draw Cooldown Icon
if proj_state &gt;= 1{

    //Calc vals and coordinates
    var cd_jig_x = 0;
    var cd_jig_y = 0;
    if cooldown_jiggler &gt; 0{
        cooldown_jiggler -= 1;
        var jiggle_strength = 4;
        cd_jig_x = random(1)*jiggle_strength;
        cd_jig_y = random(1)*jiggle_strength;
    }
    var cd_val = clamp((durTotal - durTimer)/durCooldown,0,1);
    var cd_x1 = cooldown_x -30 +cd_jig_x;
    var cd_x2 = cd_x1 +60 +cd_jig_x;
    var cd_y1 = cooldown_y -30 +cd_jig_y;
    var cd_y2 = cd_y1 +60 +cd_jig_y;
    
    //Draw cooldown icon
    //var currentAlpha = draw_get_alpha();
    //draw_set_alpha(scene_alpha);
    draw_rectangle_cd_barfill_icon_sprite_ext(cd_x1, cd_y1, cd_x2, cd_y2, cd_val,
    1,projType[projCur,0],proj_spr_color,proj_sym_color,scene_alpha) 
    //draw_set_alpha(currentAlpha);
    
    
    //we can make the jiggle independent of text maybe? oh yes it is
    if cooldown_text &gt; 0{
        draw_set_valign(fa_middle)
        draw_set_halign(fa_center)
        draw_set_font(fnt_game_bn_12_bold)
        draw_text_colour(cooldown_x,cd_y2+15,projType[projCur,3],
        COLORS[0],COLORS[0],COLORS[0],COLORS[0],scene_alpha)
        cooldown_text -= 1;
    }
        



}


//we can contemplate some alpha in and alpha tweening after we get the basic stuff working
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
